/*
 * Copyright (c) 2010, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.oracle.max.vm.ext.vma.log.txt;

import java.util.*;

import com.sun.max.program.*;

/**
 * Defines a compact textual format that uses short forms for class, field and thread names.
 * In addition, a repeated id (but not when used as a value) is, by default, passed as -1 and the
 * underlying format knows how to interpret that. This can be suppressed by setting the
 * system property {@value NO_REPEATS_PROPERTY). Repeated ids are only generated
 * for records created by the same originating thread.
 *
 * <li>classDefinitionTrackingLog: G shortclass class clid
 * <li>classDefinitionFieldTrackingLog: F shortfield field
 * <li>threadDefinitionTrackingLog: T shortthread thread
 * </ul>
 *
 * By default instances of the short forms are represented simply by their
 * integer value. This minimises log size but makes the log very hard to read by a human.
 * A single character prefix (C, F, T) can be generated by setting the
 * system property {@value PREFIX_PROPERTY}.
 *
 * We do not know the multi-threaded behavior of callers. Many threads may be synchronously
 * logging or one or more threads may be asynchronously logging records generated by
 * other threads.
 *
 * The short form maps are (necessarily) global to all threads and must be thread-safe.
 * The repeated id handling uses a thread-local as it operates across multiple
 * methods and is thread-specific.
 */

public abstract class CompactTextVMAdviceHandlerLog extends TextVMAdviceHandlerLog {

    protected final TextVMAdviceHandlerLog del;

    /*
     * Maps of short names for classes, fields and threads.
     */
    private static Map<String, String> classes = null;
    private static Map<String, String> fields = null;
    private static Map<String, String> threads = null;
    private static Map<String, LastId> repeatedIds;
    private static int classInt;
    private static int fieldInt;
    private static int threadInt;
    private static final String NO_REPEATS_PROPERTY = "max.vma.norepeatids";
    private static final String PREFIX_PROPERTY = "max.vma.shortprefix";
    private static boolean doRepeats;
    private static boolean doPrefix;

    static class LastId {
        long id = -1;
    }

    protected CompactTextVMAdviceHandlerLog(TextVMAdviceHandlerLog del) {
        super();
        this.del = del;
    }

    /**
     * Check if this {@codeobjId} is the same as the previous one.
     * Note that all traces that start with an {@code objId} must call this method!
     * @param id
     * @param threadName
     * @return -1 for a match, {@code id} otherwise
     */
    private static long checkRepeatId(long id, String threadName) {
        LastId lastId;
        if (doRepeats) {
            lastId = getLastId(threadName);
            if (lastId.id == id) {
                return -1;
            } else {
                lastId.id = id;
            }
        }
        return id;
    }

    private static LastId getLastId(String threadName) {
        synchronized (repeatedIds) {
            LastId lastId = repeatedIds.get(threadName);
            if (lastId == null) {
                lastId = new LastId();
                repeatedIds.put(threadName, lastId);
            }
            return lastId;
        }
    }

    @Override
    public boolean initializeLog() {
        classes = new HashMap<String, String>();
        fields = new HashMap<String, String>();
        threads = new HashMap<String, String>();
        repeatedIds = new HashMap<String, LastId>();
        doRepeats = System.getProperty(NO_REPEATS_PROPERTY) == null;
        doPrefix = System.getProperty(PREFIX_PROPERTY) != null;
        return del.initializeLog();
    }

    @Override
    public void finalizeLog() {
        del.finalizeLog();
    }

    @Override
    public void removal(long id) {
        del.removal(id);
    }

    @Override
    public void unseenObject(long objId,
            String className, long clId) {
        del.unseenObject(objId, getClassShortForm(className, clId), clId);
    }

    @Override
    public void resetTime() {
        del.resetTime();
    }


    protected String getClassShortForm(String className, long clId) {
        synchronized (classes) {
            String shortForm = classes.get(className);
            if (shortForm == null) {
                shortForm = doPrefix ? ("C" + classInt) : Integer.toString(classInt);
                classInt++;
                classes.put(className, shortForm);
                classDefinitionTracking(className, shortForm, clId);
            }
            return shortForm;
        }
    }

    protected String getFieldShortForm(String fieldName) {
        synchronized (fields) {
            String shortForm = fields.get(fieldName);
            if (shortForm == null) {
                shortForm = doPrefix ? ("F" + fieldInt) : Integer.toString(fieldInt);
                fieldInt++;
                fields.put(fieldName, shortForm);
                classDefinitionFieldTracking(fieldName, shortForm);
            }
            return shortForm;
        }
    }

    protected String getThreadShortForm(String threadName) {
        synchronized (threads) {
            String shortForm = threads.get(threadName);
            if (shortForm == null) {
                shortForm = doPrefix ? ("T" + threadInt) : Integer.toString(threadInt);
                threadInt++;
                threads.put(threadName, shortForm);
                threadDefinitionTracking(threadName, shortForm);
            }
            return shortForm;
        }
    }

    /**
     * Define a short form of {@code className} loaded by classloader identified by {@code clIdHash}.
     *
     * @param className
     * @param shortForm
     * @param clId
     */
    public abstract void classDefinitionTracking(String className, String shortForm, long clId);

    /**
     * Define a short form of {@code fieldName}.
     *
     * @param fieldName
     * @param shortForm
     */
    public abstract void classDefinitionFieldTracking(String fieldName, String shortForm);

    /**
     * Define a short form of {@code threadName}.
     *
     * @param threadName
     * @param shortForm
     */
    public abstract void threadDefinitionTracking(String threadName, String shortForm);

    // BEGIN GENERATED CODE

    // GENERATED -- EDIT AND RUN CompactTextVMAdviceHandlerLogGenerator.main() TO MODIFY
    @Override
    public void adviseAfterMultiNewArray(String arg1, long arg2, String arg3, long arg4, int arg5) {
        ProgramError.unexpected("adviseAfterMultiNewArray");
    }

    // GENERATED -- EDIT AND RUN CompactTextVMAdviceHandlerLogGenerator.main() TO MODIFY
    @Override
    public void adviseGC(String arg1) {
        del.adviseGC(getThreadShortForm(arg1));
    }

    // GENERATED -- EDIT AND RUN CompactTextVMAdviceHandlerLogGenerator.main() TO MODIFY
    @Override
    public void adviseThreadStarting(String arg1) {
        del.adviseThreadStarting(getThreadShortForm(arg1));
    }

    // GENERATED -- EDIT AND RUN CompactTextVMAdviceHandlerLogGenerator.main() TO MODIFY
    @Override
    public void adviseThreadTerminating(String arg1) {
        del.adviseThreadTerminating(getThreadShortForm(arg1));
    }

    // GENERATED -- EDIT AND RUN CompactTextVMAdviceHandlerLogGenerator.main() TO MODIFY
    @Override
    public void adviseBeforeArrayLoad(String arg1, long arg2, int arg3) {
        del.adviseBeforeArrayLoad(getThreadShortForm(arg1),  checkRepeatId(arg2, arg1), arg3);
    }

    // GENERATED -- EDIT AND RUN CompactTextVMAdviceHandlerLogGenerator.main() TO MODIFY
    @Override
    public void adviseBeforeArrayStore(String arg1, long arg2, int arg3, long arg4) {
        del.adviseBeforeArrayStore(getThreadShortForm(arg1),  checkRepeatId(arg2, arg1), arg3, arg4);
    }

    // GENERATED -- EDIT AND RUN CompactTextVMAdviceHandlerLogGenerator.main() TO MODIFY
    @Override
    public void adviseBeforeArrayStore(String arg1, long arg2, int arg3, double arg4) {
        del.adviseBeforeArrayStore(getThreadShortForm(arg1),  checkRepeatId(arg2, arg1), arg3, arg4);
    }

    // GENERATED -- EDIT AND RUN CompactTextVMAdviceHandlerLogGenerator.main() TO MODIFY
    @Override
    public void adviseBeforeArrayStore(String arg1, long arg2, int arg3, float arg4) {
        del.adviseBeforeArrayStore(getThreadShortForm(arg1),  checkRepeatId(arg2, arg1), arg3, arg4);
    }

    // GENERATED -- EDIT AND RUN CompactTextVMAdviceHandlerLogGenerator.main() TO MODIFY
    @Override
    public void adviseBeforeArrayStoreObject(String arg1, long arg2, int arg3, long arg4) {
        del.adviseBeforeArrayStoreObject(getThreadShortForm(arg1),  checkRepeatId(arg2, arg1), arg3, arg4);
    }

    // GENERATED -- EDIT AND RUN CompactTextVMAdviceHandlerLogGenerator.main() TO MODIFY
    @Override
    public void adviseBeforeGetStatic(String arg1, String arg2, long arg3, String arg4) {
        del.adviseBeforeGetStatic(getThreadShortForm(arg1), getClassShortForm(arg2, arg3), arg3, getFieldShortForm(arg4));
    }

    // GENERATED -- EDIT AND RUN CompactTextVMAdviceHandlerLogGenerator.main() TO MODIFY
    @Override
    public void adviseBeforePutStatic(String arg1, String arg2, long arg3, String arg4, double arg5) {
        del.adviseBeforePutStatic(getThreadShortForm(arg1), getClassShortForm(arg2, arg3), arg3, getFieldShortForm(arg4), arg5);
    }

    // GENERATED -- EDIT AND RUN CompactTextVMAdviceHandlerLogGenerator.main() TO MODIFY
    @Override
    public void adviseBeforePutStatic(String arg1, String arg2, long arg3, String arg4, float arg5) {
        del.adviseBeforePutStatic(getThreadShortForm(arg1), getClassShortForm(arg2, arg3), arg3, getFieldShortForm(arg4), arg5);
    }

    // GENERATED -- EDIT AND RUN CompactTextVMAdviceHandlerLogGenerator.main() TO MODIFY
    @Override
    public void adviseBeforePutStatic(String arg1, String arg2, long arg3, String arg4, long arg5) {
        del.adviseBeforePutStatic(getThreadShortForm(arg1), getClassShortForm(arg2, arg3), arg3, getFieldShortForm(arg4), arg5);
    }

    // GENERATED -- EDIT AND RUN CompactTextVMAdviceHandlerLogGenerator.main() TO MODIFY
    @Override
    public void adviseBeforePutStaticObject(String arg1, String arg2, long arg3, String arg4, long arg5) {
        del.adviseBeforePutStaticObject(getThreadShortForm(arg1), getClassShortForm(arg2, arg3), arg3, getFieldShortForm(arg4), arg5);
    }

    // GENERATED -- EDIT AND RUN CompactTextVMAdviceHandlerLogGenerator.main() TO MODIFY
    @Override
    public void adviseBeforeGetField(String arg1, long arg2, String arg3) {
        del.adviseBeforeGetField(getThreadShortForm(arg1), checkRepeatId(arg2, arg1), getFieldShortForm(arg3));
    }

    // GENERATED -- EDIT AND RUN CompactTextVMAdviceHandlerLogGenerator.main() TO MODIFY
    @Override
    public void adviseBeforePutField(String arg1, long arg2, String arg3, long arg4) {
        del.adviseBeforePutField(getThreadShortForm(arg1), checkRepeatId(arg2, arg1), getFieldShortForm(arg3), arg4);
    }

    // GENERATED -- EDIT AND RUN CompactTextVMAdviceHandlerLogGenerator.main() TO MODIFY
    @Override
    public void adviseBeforePutField(String arg1, long arg2, String arg3, float arg4) {
        del.adviseBeforePutField(getThreadShortForm(arg1), checkRepeatId(arg2, arg1), getFieldShortForm(arg3), arg4);
    }

    // GENERATED -- EDIT AND RUN CompactTextVMAdviceHandlerLogGenerator.main() TO MODIFY
    @Override
    public void adviseBeforePutField(String arg1, long arg2, String arg3, double arg4) {
        del.adviseBeforePutField(getThreadShortForm(arg1), checkRepeatId(arg2, arg1), getFieldShortForm(arg3), arg4);
    }

    // GENERATED -- EDIT AND RUN CompactTextVMAdviceHandlerLogGenerator.main() TO MODIFY
    @Override
    public void adviseBeforePutFieldObject(String arg1, long arg2, String arg3, long arg4) {
        del.adviseBeforePutFieldObject(getThreadShortForm(arg1), checkRepeatId(arg2, arg1), getFieldShortForm(arg3), arg4);
    }

    // GENERATED -- EDIT AND RUN CompactTextVMAdviceHandlerLogGenerator.main() TO MODIFY
    @Override
    public void adviseAfterInvokeSpecial(String arg1, long arg2) {
        del.adviseAfterInvokeSpecial(getThreadShortForm(arg1), checkRepeatId(arg2, arg1));
    }

    // GENERATED -- EDIT AND RUN CompactTextVMAdviceHandlerLogGenerator.main() TO MODIFY
    @Override
    public void adviseAfterNew(String arg1, long arg2, String arg3, long arg4) {
        del.adviseAfterNew(getThreadShortForm(arg1), checkRepeatId(arg2, arg1), getClassShortForm(arg3, arg4), arg4);
    }

    // GENERATED -- EDIT AND RUN CompactTextVMAdviceHandlerLogGenerator.main() TO MODIFY
    @Override
    public void adviseAfterNewArray(String arg1, long arg2, String arg3, long arg4, int arg5) {
        del.adviseAfterNewArray(getThreadShortForm(arg1), checkRepeatId(arg2, arg1), getClassShortForm(arg3, arg4), arg4, arg5);
    }



}
