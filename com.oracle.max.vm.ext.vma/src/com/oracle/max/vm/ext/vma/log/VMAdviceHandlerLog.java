/*
 * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.oracle.max.vm.ext.vma.log;

import com.oracle.max.vm.ext.vma.*;

/**
 * An interface that is derived from {@link VMAdviceHandler} but is suitable for persistent storage. I.e., object
 * instances are represented by unique identifiers, class instances by their name and classloader instance id, method by
 * name, etc.
 *
 * Although wall clock time of the event is an important consideration, its generation is left to the logging
 * implementation. That is, it is expected that there is no material delay between the actual event and the logging.
 *
 * A logger is responsible for generating the timestamp for an event. By default this class provides a
 * {@link TimeStampGenerator generator} that returns system time. However, it is possible to set a different
 * implementation after constructing the logger. This is particularly useful when converting one log format to another in
 * order to preserve the original timestamps.
 *
 * A log implementation must be thread-safe either by design or by appropriate synchronization.
 *
 * Much of this class is auto-generated by {@link VMAdviceHandlerLogGenerator}.
 *
 */
public abstract class VMAdviceHandlerLog {

    public interface TimeStampGenerator {
        /**
         * Get the time stamp for a trace.
         * @return absolute wall clock time of the trace
         */
        long getTimeStamp();
    }

    public TimeStampGenerator timeStampGenerator;

    protected static class SystemTimeGenerator implements TimeStampGenerator {
        public long getTimeStamp() {
            return System.nanoTime();
        }
    }

    protected VMAdviceHandlerLog() {
        this(new SystemTimeGenerator());
    }

    private VMAdviceHandlerLog(TimeStampGenerator timeStampGenerator) {
        this.timeStampGenerator = timeStampGenerator;
    }

    /**
     * Initialize the logging subsystem.
     *
     * @return {@code true} iff the initialization was successful.
     */
    public abstract boolean initializeLog();

    /**
     * Finalize the logging, e.g. flush trace.
     */
    public abstract void finalizeLog();

    /**
     * Explicitly set the time stamp generator.
     * @param timeStampGenerator
     */
    public void setTimeStampGenerator(TimeStampGenerator timeStampGenerator) {
        this.timeStampGenerator = timeStampGenerator;
    }

    /**
     * Log the removal on an object from the VM (i.e. object death).
     * @param id
     */
    public abstract void removal(long id);

    /**
     * Log an object that was not seen by the adviseNEW methods but was used in an operation.
     *
     * @param objId
     * @param className
     * @param clId
     */
    public abstract void unseenObject(long objId, String className, long clId);

    /**
     * Available for the rare case where log records are not time ordered.
     * This resets the absolute time.
     * @param time
     */
    public abstract void resetTime();

     // BEGIN GENERATED CODE

    // GENERATED -- EDIT AND RUN VMAdviceHandlerLogGenerator.main() TO MODIFY
    public abstract void adviseGC(String threadName);

    // GENERATED -- EDIT AND RUN VMAdviceHandlerLogGenerator.main() TO MODIFY
    public abstract void adviseThreadStarting(String threadName);

    // GENERATED -- EDIT AND RUN VMAdviceHandlerLogGenerator.main() TO MODIFY
    public abstract void adviseThreadTerminating(String threadName);

    // GENERATED -- EDIT AND RUN VMAdviceHandlerLogGenerator.main() TO MODIFY
    public abstract void adviseBeforeArrayLoad(String threadName, long objId, int index);

    // GENERATED -- EDIT AND RUN VMAdviceHandlerLogGenerator.main() TO MODIFY
    public abstract void adviseBeforeArrayStore(String threadName, long objId, int index, float value);

    // GENERATED -- EDIT AND RUN VMAdviceHandlerLogGenerator.main() TO MODIFY
    public abstract void adviseBeforeArrayStore(String threadName, long objId, int index, long value);

    // GENERATED -- EDIT AND RUN VMAdviceHandlerLogGenerator.main() TO MODIFY
    public abstract void adviseBeforeArrayStore(String threadName, long objId, int index, double value);

    // GENERATED -- EDIT AND RUN VMAdviceHandlerLogGenerator.main() TO MODIFY
    public abstract void adviseBeforeArrayStoreObject(String threadName, long objId, int index, long value);

    // GENERATED -- EDIT AND RUN VMAdviceHandlerLogGenerator.main() TO MODIFY
    public abstract void adviseBeforeGetStatic(String threadName, String className, long clId, String fieldName);

    // GENERATED -- EDIT AND RUN VMAdviceHandlerLogGenerator.main() TO MODIFY
    public abstract void adviseBeforePutStatic(String threadName, String className, long clId, String fieldName, long value);

    // GENERATED -- EDIT AND RUN VMAdviceHandlerLogGenerator.main() TO MODIFY
    public abstract void adviseBeforePutStatic(String threadName, String className, long clId, String fieldName, double value);

    // GENERATED -- EDIT AND RUN VMAdviceHandlerLogGenerator.main() TO MODIFY
    public abstract void adviseBeforePutStatic(String threadName, String className, long clId, String fieldName, float value);

    // GENERATED -- EDIT AND RUN VMAdviceHandlerLogGenerator.main() TO MODIFY
    public abstract void adviseBeforePutStaticObject(String threadName, String className, long clId, String fieldName, long value);

    // GENERATED -- EDIT AND RUN VMAdviceHandlerLogGenerator.main() TO MODIFY
    public abstract void adviseBeforeGetField(String threadName, long objId, String fieldName);

    // GENERATED -- EDIT AND RUN VMAdviceHandlerLogGenerator.main() TO MODIFY
    public abstract void adviseBeforePutField(String threadName, long objId, String fieldName, float value);

    // GENERATED -- EDIT AND RUN VMAdviceHandlerLogGenerator.main() TO MODIFY
    public abstract void adviseBeforePutField(String threadName, long objId, String fieldName, double value);

    // GENERATED -- EDIT AND RUN VMAdviceHandlerLogGenerator.main() TO MODIFY
    public abstract void adviseBeforePutField(String threadName, long objId, String fieldName, long value);

    // GENERATED -- EDIT AND RUN VMAdviceHandlerLogGenerator.main() TO MODIFY
    public abstract void adviseBeforePutFieldObject(String threadName, long objId, String fieldName, long value);

    // GENERATED -- EDIT AND RUN VMAdviceHandlerLogGenerator.main() TO MODIFY
    public abstract void adviseAfterInvokeSpecial(String threadName, long objId);

    // GENERATED -- EDIT AND RUN VMAdviceHandlerLogGenerator.main() TO MODIFY
    public abstract void adviseAfterNew(String threadName, long objId, String className, long clId);

    // GENERATED -- EDIT AND RUN VMAdviceHandlerLogGenerator.main() TO MODIFY
    public abstract void adviseAfterNewArray(String threadName, long objId, String className, long clId, int length);

    // GENERATED -- EDIT AND RUN VMAdviceHandlerLogGenerator.main() TO MODIFY
    public abstract void adviseAfterMultiNewArray(String threadName, long objId, String className, long clId, int length);


}
