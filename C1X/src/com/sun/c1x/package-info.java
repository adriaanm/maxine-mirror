package com.sun.c1x;

import com.sun.c1x.ir.*;
import com.sun.c1x.value.*;
import com.sun.c1x.alloc.LinearScan;
import com.sun.c1x.alloc.IntervalWalker;
import com.sun.c1x.lir.LIRDebugInfo;
import com.sun.c1x.lir.LIRInstruction;
import com.sun.c1x.ci.CiDebugInfo;
import com.sun.c1x.ci.CiTargetMethod;
import com.sun.c1x.ci.CiRuntimeCall;
import com.sun.c1x.ci.CiRegister;
import com.sun.c1x.target.x86.X86;
import com.sun.c1x.target.x86.X86MacroAssembler;
import com.sun.c1x.target.x86.X86GlobalStubEmitter;
import com.sun.c1x.target.AMD64;
import com.sun.c1x.graph.GraphBuilder;
import com.sun.c1x.opt.LoopPeeler;
import com.sun.c1x.ri.RiMethod;

/**
 * This is a collection of notes about the C1X compiler, including future directions, refactorings,
 * missing features, broken features, etc.
 *
 *
 * <h3>Anticipated Refactorings</h3>
 *
 * <ul>
 * <li>
 * The HIR nodes {@link UnsafePrefetch}, {@link UnsafePutObject}, etc should
 * be replaced by uses of the newer {@link LoadPointer} and {@link com.sun.c1x.ir.StorePointer}
 * nodes. Currently, the unsafe nodes are only generated by the creation of an OSR entry.
 * Benefit: reduce the number of different IR nodes.
 * </li>
 *
 * <li>
 * Add a field to optionally store an {@link Info} object for each HIR node, and remove the
 * {@link Instruction#exceptionHandlers} field, the {@link Instruction#bci} field, and any
 * fields to store the Java frame state in subclasses.
 * Benefit: saves space if most HIR nodes do not have exception handlers, a bci or Java frame
 * state. Removes virtual dispatch on accessing debug information for nodes. Allows any node,
 * regardless of its type, to have info attached.
 * </li>
 *
 * <li>
 * Migrate all HIR nodes to use the immutable {@link JavaFrameState} for debugging information.
 * The {@link ValueStack} class is mutable and used throughout graph building.
 * Benefit:
 * {@link JavaFrameState} would save both total space in the IR graph prevent many bugs due
 * to the mutability of {@link ValueStack}.
 * </li>
 *
 * <li>
 * Move the {@link ValueStack} class to an inner class, or combine entirely, with the {@link GraphBuilder}
 * class. After the introduction of the {@link JavaFrameState} into HIR nodes, the mutable value stack
 * should only need to be accessed from the graph builder.
 * </li>
 *
 * </ul>
 *
 * <h3>Missing or incomplete features</h3>
 *
 * There are some features of C1 that were not ported forward or finished given the time constraints for
 * the C1X port. A list appears below.
 *
 * <ul>
 * <li>
 * Deoptimization metadata. The locations of all local variables and stack values are not communicated
 * back to the runtime system through the {@link CiDebugInfo} class yet. Such values
 * are known to the register allocator, and there vestigial logic to compute them still there
 * in the {@link LinearScan#computeDebugInfo(IntervalWalker, LIRInstruction)} method.
 * To complete this metadata, the {@link LinearScan} class must implement the
 * {@link LIRDebugInfo.ValueLocator} interface and pass it to the
 * {@link LIRDebugInfo#createFrame(ValueStack, int, LIRDebugInfo.ValueLocator)}
 * method after register allocation. The resulting debug info will be fed back to the runtime system by the existing logic that calls
 * {@link CiTargetMethod#recordCall(int, Object, CiDebugInfo, byte[], boolean)} and other
 * methods. Obviously the runtime system will need to encode this metadata in a dense format, because it is huge.
 * </li>
 *
 *
 * <li>
 * Tiered compilation support. C1 supported the ability to add instrumentation to branches, invocations,
 * and checkcasts in order to feed profile information to the C2 compiler in a tiered compilation setup.
 * It relied on adding some information to the HIR nodes that represent these operations
 * ({@link Invoke}, {@link CheckCast}, etc).
 * All of this logic was removed to simplify both the front end and back end in anticipation of
 * designing a future instrumentation API. XIR should be general enough to allow instrumentation
 * code to be added to invocation and checkcast sites, but currently has no support for adding
 * code at branches.
 *
 * </li>
 *
 * <li>
 * 32-bit x86 support. Although the platform configuration has a base class
 * {@link X86} which is extended by a 64-bit version
 * {@link AMD64}, there is no corresponding 32-bit class. Such a class
 * could be added easily, since the enumeration of registers in the base class already
 * separates them into 32 and 64 bit sets. The x86 backend inherited from C1 supports both
 * 32-bit and 64-bit code generation by checking the architecture word size in numerous places.
 * However, there are a number of places in the backend where the 32-bit code was left out;
 * most of these places will throw {@link AssertionError} if the word size
 * is not 64-bits and will need the appropriate 32-bit logic written. Unfortunately, there may be other places
 * in the computation of stack offsets or spill slot indices that may not be wordsize portable and may
 * require debugging if a 32-bit port is attempted.
 * </li>
 *
 * <li>
 * SPARC and other architecture support. There pretty well-delineated separation between the
 * architecture-independent part of LIR backend and the architecture-dependent, but the only
 * implementation that current exists is the X86 backend
 * ({@link com.sun.c1x.target.x86.X86Backend},
 * {@link com.sun.c1x.target.x86.X86LIRGenerator},
 * {@link com.sun.c1x.target.x86.X86LIRAssembler}, etc).
 * </li>
 *
 * <li>
 * XIR for safepoints. The C1X backend should use XIR to get the code for safepoints,
 * but currently it still uses the handwritten logic (currently only compatible with Maxine).
 * </li>
 *
 * </ul>
 *
 * <h3>Untested features</h3>
 *
 * <ul>
 *
 * <li>
 * Reference map for outgoing overflow arguments. If a C1X method calls another method that
 * has overflow arguments, it is not clear if the outgoing overflow argument area, which may
 * contain references, has the appropriate bits set in the reference map for the C1X method's
 * frame. Such arguments may be live in the called method.
 * </li>
 *
 * <li>
 * Although it should work, inlining synchronized methods or methods with exception handlers hasn't
 * been tested.
 * </li>
 * <li>
 * On-stack replacement. C1X retains all of the special logic for performing an OSR compilation. This
 * is basically a compilation with a second entrypoint for entry from the interpreter. However, the
 * generation of a runtime-specific entry sequence was never tested.
 * </li>
 *
 * <li>
 * {@link C1XIntrinsic Intrisification} is the mechanism by which the compiler recognizes calls
 * to special JDK or runtime methods and replaces them with custom code. It is enabled by the
 * {@link C1XOptions#OptIntrinsify} compiler option. The C1X backend has never been tested
 * with intrinsified arithmetic or floating point operations. For best performance, it should generate
 * specialized machine code for arithmetic and floating point, perhaps using global stubs for complex
 * floating point operations.
 * <br>
 * <i>Note</i>: Folding of special intrinsified methods is supported, tested, and working.
 * The runtime system may register methods to be folded by using the
 * {@link C1XIntrinsic#registerFoldableMethod(RiMethod, java.lang.reflect.Method)}
 * call. When the compiler encounters a call to such a registered method where the parameters are all constants,
 * it invokes the supplied method with reflection. If the reflective call produces a value and does not throw an
 * exception, C1X replaces the call to the method with the result.
 * </li>
 * </ul>
 *
 * <h3>Broken features</h3>
 *
 * <ul>
 * <li>
 * {@link LoopPeeler Loop peeling} was written by Marcelo Cintra near the end of his internship.
 * It was never completed and should be considered broken. It only remains as a sketch of how loop peeling would
 * be implemented in C1X, or in case he would finish the implementation and test it.
 * </li>
 *
 * <li>
 * Calls to global stubs should allocate space on the caller's stack. On AMD64 currently, calls to global stubs poke
 * the arguments onto the stack below the RSP (i.e. in the callee's stack). While normally this code sequence
 * is uninterruptible and works fine in the VM, signal handlers triggered when debugging or inspecting this code
 * sequence may destroy these values when the OS calls the signal handler. This requires knowing which global
 * stubs are called before finalizing the frame size; currently only the calls to
 * {@link X86MacroAssembler#callRuntimeCalleeSaved(CiRuntimeCall, LIRDebugInfo, CiRegister, Object[])}
 * do not fit this pattern. This needs to be fixed so that all global stubs that are called by the assembled
 * code are known before beginning assembling. The {@link X86GlobalStubEmitter} controls
 * how the global stubs accept their parameters. See {@link X86GlobalStubEmitter#callerFrameContainsArguments}
 * and its usages.
 *
 * </li>
 * </ul>
 */
