Limitations on compilations in C1 and C1X

StrictFP:
   - C1X retains the mechanisms to generate FPU stack code for non-SSE Intel processors,
     but it is not currently tested or used. Because of this, strictfp-ness of
     methods doesn't really matter currently.
   - C1 will not inline methods with different strictfp-ness. C1X does not have this
     limitation.

JSR/RET
   - C1 will bail out if it encounters strange JSR/RET patterns
       - recursive JSRs
       - JSR regions that are shared with non-JSR code
       - RET encountered out of JSR (would not verify)

Exceptions
   -  C1 will bailout if the code of an exception handler can be reached via normal
      control flow.
   => C1X might be extended to introduce a phi for the exception
      object in this case.
   -  C1 will bailout if an exception handler covers itself

Verification
   -  C1 does not rely on bytecode verification having been run. However, if it detects
      type errors in its building the IR graph it will usually bail out.
   -  C1 requires a bitmap of the bytecode, where a bit for
      each byte of the bytecode indicates if the bytecode at that location starts a
      basic block. It uses this to construct the basic block list in a single pass.
   => C1X's BlockMap does not computes the basic block starts in one pass over the bytecode
      and one pass over the successor lists.

Synchronization
   -  C1 will refuse to compile methods with unbalanced synchronization. This property is
      computed by the bytecode verifier and supplied to C1.
   => C1X will not rely on the bytecode verifier to compute this but should do so itself.

Constant Folding / Strength reduction
   -  C1 had some of its strength reduction logic built into the GraphBuilder because
      the Canonicalizer could not return multiple instructions.
   => C1X added this ability, moved the logic to Canonicalizer, and added a few new
      strength reductions.
   => C1X should have an interface for doing folding of @FOLD method calls
   => C1X folds many intrinsic operations that don't have side effects
   => C1X folds all the basic floating point operations
   => C1X strength reduces (e >> C >> K) to (e >> (C + K)) when C and K are constant

Switches
   -  C1 did not detect back edges in tableswitch/lookupswitch default branches
   => C1X does detect these back edges
   => C1X moved the canonicalization code of 1 and 2 branch switches to canonicalizer,
      where it belongs

Inlining
   -  C1 cannot inline:
      -  native methods (or their stubs), except some intrinsics
      -  methods whose class has not been initialized
      -  methods with unbalanced monitors
      -  methods with JSRs (this is probably technically possible now)

   -  C1 will not inline:
      -  methods with exception handlers (optional)
      -  synchronized methods (optional)
      -  if the maximum inline depth is reached (default = 9)
      -  if the maximum recursive inline depth is reached (default = 1)
      -  if the callee is larger than the maximum inline size (reduced to 90% at each level, starting at 35)
      -  constructors for subclasses of Throwable
      -  if the strictfp-ness of the callee is different than the caller (on x87)
      -  abstract methods
      -  synchronized intrinsics

Load/store elimination
   => C1X eliminates loads of static fields, which C1 did not
   => C1X distinguishes loads/stores to different fields in MemoryBuffer
   => C1X assumes that CiField instances are unique when .isLoaded() is true

BlockListBuilder
   -  C1 had a vestigial loop map in BlockListBuilder
   => C1X does not need to compute a complete loop map in order to do selective phi creation,
      it builds the "storesInLoops" BitMap in BlockMap

Types
   => C1X adds the declared type of method parameters to Local instructions, which
      may help with devirtualization
   => C1X makes local 0 of instance methods non-null at the start

