/*
 * Copyright (c) 2007 Sun Microsystems, Inc.  All rights reserved.
 *
 * Sun Microsystems, Inc. has intellectual property rights relating to technology embodied in the product
 * that is described in this document. In particular, and without limitation, these intellectual property
 * rights may include one or more of the U.S. patents listed at http://www.sun.com/patents and one or
 * more additional patents or pending patent applications in the U.S. and in other countries.
 *
 * U.S. Government Rights - Commercial software. Government users are subject to the Sun
 * Microsystems, Inc. standard license agreement and applicable provisions of the FAR and its
 * supplements.
 *
 * Use is subject to license terms. Sun, Sun Microsystems, the Sun logo, Java and Solaris are trademarks or
 * registered trademarks of Sun Microsystems, Inc. in the U.S. and other countries. All SPARC trademarks
 * are used under license and are trademarks or registered trademarks of SPARC International, Inc. in the
 * U.S. and other countries.
 *
 * UNIX is a registered trademark in the U.S. and other countries, exclusively licensed through X/Open
 * Company, Ltd.
 */
package test.com.sun.max.vm.jtrun;

import static com.sun.max.vm.VMOptions.*;

import com.sun.max.annotate.*;
import com.sun.max.vm.*;
import com.sun.max.vm.actor.holder.*;
import com.sun.max.vm.actor.member.*;
import com.sun.max.vm.classfile.constant.*;
import com.sun.max.vm.prototype.*;
import com.sun.max.vm.run.java.*;

/**
 * This abstract run scheme is shared by all the concrete run schemes generated by the {@link JavaTesterGenerator}.
 * It behave as the standard {@link JavaRunScheme} if a main class is specified on the command.
 * If no main class is specified, then the tests will be run and the VM will exit.
 *
 * @author Doug Simon
 */
public abstract class AbstractTester extends JavaRunScheme {

    protected static Utf8Constant testMethod = SymbolTable.makeSymbol("test");
    protected static boolean nativeTests;
    protected static boolean noTests;
    protected static int passed;
    protected static int finished;
    protected static int total;
    protected static int testNum;
    protected static int testStart;
    protected static int testEnd;
    protected static int testCount;
    protected static int verbose = 2;
    protected static String lastTestName;

    private static VMIntOption startOption = register(new VMIntOption("-XX:TesterStart=", -1,
                    "The number of the first test to run."), MaxineVM.Phase.STARTING);
    private static VMIntOption endOption  = register(new VMIntOption("-XX:TesterEnd=", -1,
                    "The number of the last test to run. Specify 0 to run exactly one test."), MaxineVM.Phase.STARTING);
    private static final boolean COMPILE_ALL_TEST_METHODS = true;

    public static void reportPassed(int passed, int total) {
        Log.print("Done: ");
        Log.print(passed);
        Log.print(" of ");
        Log.print(total);
        Log.println(" passed.");
    }

    public static void end(String run, boolean result) {
        if (result) {
            passed++;
        }
        if (verbose == 2) {
            verbose(result, ++finished, total);
        }
        if (verbose == 3) {
            if (!result) {
                printRun(run);
                Log.println(" failed with incorrect result");
            }
        }
        testNum++;
    }

    public static void end(String run, Throwable t) {
        if (verbose == 2) {
            verbose(false, ++finished, total);
        }
        if (verbose == 3) {
            printRun(run);
            Log.print(" failed with exception !");
            Log.println(t.getClass().getName());
        }
        testNum++;
    }

    private static void printRun(String run) {
        Log.print("\t");
        printTestNum();
        if (lastTestName != null) {
            Log.print(lastTestName);
        }
        if (run != null) {
            Log.print(".test");
            Log.print(run);
        }
    }

    public static void verbose(boolean passed, int finished, int total) {
        Log.print(passed ? '.' : 'X');
        if (finished % 10 == 0) {
            Log.print(' ');
        }
        if (finished % 50 == 0) {
            Log.print(' ');
            Log.print(finished);
            Log.print(" of ");
            Log.println(total);
        } else if (finished == total) {
            Log.println();
        }
    }

    public static void begin(String test) {
        if (verbose == 3) {
            printTestNum();
            Log.print(test);
            lastTestName = test;
            int i = test.length();
            while (i++ < 50) {
                Log.print(' ');
            }
            Log.println("  next: '" + startOption + (testNum + 1) + "', end: '" + endOption + testCount + "'");
        }
    }

    public static void printTestNum() {
        // print out the test number (aligned to the left)
        Log.print(testNum);
        Log.print(':');
        if (testNum < 100) {
            Log.print(' ');
        }
        if (testNum < 10) {
            Log.print(' ');
        }
        Log.print(' ');
    }

    public AbstractTester(VMConfiguration vmConfiguration) {
        super(vmConfiguration);
    }

    @PROTOTYPE_ONLY
    public void addClassToImage(Class<?> javaClass) {
        final ClassActor actor = ClassActor.fromJava(javaClass);
        if (actor == null) {
            return;
        }
        if (BootImageGenerator.calleeJit) {
            CompiledPrototype.registerJitClass(javaClass);
        }
        if (BootImageGenerator.calleeC1X) {
            CompiledPrototype.registerC1XClass(javaClass);
        }
        if (BootImageGenerator.unlinked) {
            CompiledPrototype.registerClassUnlinked(actor);
        }
        if (COMPILE_ALL_TEST_METHODS) {
            // add all virtual and static methods to the image
            addMethods(actor.localStaticMethodActors());
            addMethods(actor.localVirtualMethodActors());
        } else {
            // add only the test method to the image
            final StaticMethodActor method = actor.findLocalStaticMethodActor(testMethod);
            if (method != null) {
                addMethodToImage(method);
            }
        }
        for (Class<?> declaredClass : javaClass.getDeclaredClasses()) {
            // load all inner and anonymous classes into the image as well
            addClassToImage(declaredClass);
        }
    }

    @PROTOTYPE_ONLY
    private void addMethods(ClassMethodActor[] methodActors) {
        if (methodActors != null) {
            for (ClassMethodActor method : methodActors) {
                addMethodToImage(method);
            }
        }
    }

    @PROTOTYPE_ONLY
    private void addMethodToImage(ClassMethodActor method) {
        CompiledPrototype.registerImageMethod(method);
        if (BootImageGenerator.unlinked) {
            CompiledPrototype.registerMethodUnlinked(method);
        }
    }

    @PROTOTYPE_ONLY
    private void registerClasses() {
        if (BootImageGenerator.callerJit) {
            CompiledPrototype.registerJitClass(test.com.sun.max.vm.jtrun.some.JavaTesterTests.class);
            CompiledPrototype.registerJitClass(test.com.sun.max.vm.jtrun.all.JavaTesterTests.class);
        }
        for (Class<?> testClass : getClassList()) {
            addClassToImage(testClass);
        }
    }

    @Override
    protected boolean parseMain() {
        return noTests;
    }

    protected abstract void runTests();

    @Override
    public void initialize(MaxineVM.Phase phase) {
        noTests = VMOptions.parseMain(false);
        if (phase == MaxineVM.Phase.STARTING) {
            if (nativeTests || noTests) {
                super.initialize(phase);
            }
            if (!noTests) {
                testStart = startOption.getValue();
                if (testStart < 0) {
                    testStart = 0;
                }
                final int end = endOption.getValue();
                if (end == 0) {
                    testEnd = testStart + 1;
                } else if (end > 0) {
                    testEnd = end;
                } else {
                    testEnd = testCount;
                }
                if (nativeTests) {
                    System.loadLibrary("javatest");
                }
                runTests();
            }
        } else {
            super.initialize(phase);
        }
        verbose = 3;
        if (MaxineVM.isPrototyping()) {
            registerClasses();
            nativeTests = BootImageGenerator.nativeTests;
            testCount = getClassList().length;
            super.initialize(phase);
        }
    }

    @PROTOTYPE_ONLY
    public abstract Class[] getClassList();
}
