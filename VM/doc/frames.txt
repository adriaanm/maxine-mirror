This document describes the design of the stack walking/unwinding mechanism in Maxine.

The primary tasks of a stack walking mechanism are:

1. Proceed from the frame for a method invocation to the frame of the caller.
2. Expose the variables in the frame.

We want a mechanism that works for a stack containing frames for different forms of executing code.
The possible code types are:

o Code compiled by the optimizing compiler
o Code compiled by the JIT
o Code compiled by other compilers
o Code being interpreted
o Native code

The layout of a frame for each of these code types may be different. As such,
the means by which task 1 and 2 are accomplished for any given frame will
be potentially be very different. This immediately suggests that these
tasks need to be abstracted appropriately with some shared mechanism
for co-ordinating a complete stack walk based on these abstractions.

One other requirement is for the mechanism to work (unmodified as much as possible)
when inspecting a stack in a remote/debuggee Maxine VM process.

Despite the fact that each form of code will have a different stack layout,
there needs to be some agreed upon protocol.


Calling conventions
===================


Each form of executable code has its own calling convention that includes:

1. Where the incoming parameters are to be found.
2. Where the result value (if any) will be written.
3. Where outgoing parameters will be placed.
4. Where the result of a called function should be placed.


OPTO = 0
JIT = 1
INT = 2

+0:OPTO   jmp L1
+2:JIT    jmp L2
+4:INT    jmp L3
+6:L2     mov ...
          mov ...
          mov ...
          mov ...
          call L1
          mov ...
          mov ...
          ret
+20:L3    mov ...
          mov ...
          call L1
          mov ...
          mov ...
          ret
+25: L1   subq rsp, 34
          ...
          addq rsp, 34
          ret
          
          
          
Transitions into/out of native code
===================================

   RootScanningThread                 JavaThread

                                         A()
                                          | ...
                                          | call B
                                           \
                                            B() [JNI stub]
                                            | ...
                                            | mov R1 TLS
                                            | ...
                                            | mov [R1 + lastJavaFP] RSP
                                            | lea R2 .
                                            | mov [R1 + lastJavaPC] R2
                                            | call nativeB
                                             \
                                              nativeB()
                                              | ...
                                              | ret
                                             /
                                            | mov [R1 + lastJavaPC] 0
                                           
                                          
                                          
   
