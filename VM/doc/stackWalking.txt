All the shapes and states of execution stack frames and how to tell them apart.
-------------------------------------------------------------------------------

All stacks grow downwards in a linear address space.


1. Java frames
--------------

Our two compilers have completely different activation frame layouts.
Whereas the fast JIT's objective is to directly model a Java stack,
the optimizing compiler's game is register allocation with spilling.
The JIT uses two registers to manage a frame.

Each generated method may have several entry points.
Which entry point is used, depends on who is calling.

@see CallEntryPoint


1.1 Optimizing compiler frames
------------------------------

Optimizing compiler frames have a fixed size.
There are no push and pop operations.
The stack pointer is bumped once on frame entry and then retracted on frame exit.
It serves as a de facto frame pointer to access local frame slots and parameters.
All stack accesses go through this fixed stack/frame pointer.
Since calls and returns typically use a register that has been
designated as "the stack pointer" by the ISA,
this is the register we use as stack/frame pointer.
In the following we refer to it as the frame pointer
when we mean its role and as SP 
when we mean the physical register from the ISA that implements it.

Most arguments are passed via registers.
Only in case there are "many" parameters,
some arguments may be passed on the stack.
A caller places these at the low address end of its frame and then executes a CALL. 
When the callee method starts executing,
it's SP points to the slot where the caller's CALL instruction left the return address.

---------------------
caller frame

arguments
---------------------
return address
--------------------- <-- SP

If the callee needs any stack slots of its own,
for spilling or for placing call parameters to subsequent downcalls,
it will reserve stack space in its very first instruction,
which subtracts the appropriate amount of bytes from SP, e.g.:

SP -= 32 // 4 slots

For a slot size of 8 bytes the stack contains these items:

----------------------
caller frame

arguments
----------------------
return address
----------------------
callee slot 3
--------------
callee slot 2
--------------
callee slot 1
--------------
callee slot 0
---------------------- <-- SP

Before every return (RET) instruction,
the callee executes a compensating addition to SP, e.g.

SP += 32 // 4 slots


1.2 JIT frames
--------------

These are the principal areas in a JIT frame:

-------------------                      ---
incoming parameters                       ^
-------------------                       |
caller's save area                     totalFrameSize          
-------------------            ---        |
template spill area             ^         |
------------------- <-- FP      |         |
Java locals               calleeFrameSize |  
-------------------             |         |
Java Stack                      v         v
------------------- <-- SP     ---       ---

Incoming parameters are pushed by the caller on top of its operand
stacks. These become part of the frame of the callee upon method
invocation.

The frame is made of 5 areas:
1. The incoming parameters area, allocated by the callee on its
 operand stack. The size of this area can be inferred from the
 signature of the callee.
2. the caller's save area, which comprises caller's RIP and its own
 frame pointer FP.
3. The template spill area. This area is reserved for templates
 built by the optimizing compiler and copied at JIT-time. 
4. The Java Locals area, which contains local variables as described in the JVM spec, except for incoming parameters.
 These remain in the first area mentioned above.
5. The Java Stack area, which acts as the operand stack as described
 in the JVM specifications.

 The frame pointer points to the base of the template spill
 area. Templates are compiled by the optimizing compiler using the
 frame pointer as the base for their spill area. The JIT arranges for
 its spill area to match that of the templates it uses. The template
 area is always empty when crossing a template boundary in the JIT
 code.

 This layout (FP pointer to the base of the template area) allows a
 template to be emitted by the JIT-compiler without changing the
 offset to the spill area used by the template (and therefore, requiring no
 mechanism to identify and modify spill/reload instructions in templates).

 JIT code makes two different kinds of calls: Java calls and runtime calls.
 Java calls model application method invocations, and the calling
 convention is implemented by the JIT itself.

 Runtime calls form part of internal bytecode implementations. They
 are compiled by the optimizing compiler and follows the optimizing
 compiler calling convention.


1.2.1 Java call
---------------

When a JIT method calls another Java method, it calls the JIT entry point
of the method. 
Executing bytecodes have already placed all arguments onto the Java
stack. 

The callee's frame then looks like this:

-----------------------
incoming parameters
----------------------- 
caller's return address 
----------------------- <-- SP

The FP register still holds the caller's frame pointer.

Next, the prologue of the callee saves the caller's frame pointer and
set it's own frame pointer: 
   callee SP = SP + 1 + template spill area + non-parameter locals
   FP = callee SP - non-parameter locals

Thus, the first two instructions of a prologue (on AMD 64) typically
looks like this: 
 
   enter  <1 + template spill area + non-parameter locals>
   subq   FP, <template spill area>

The first instruction set SP to the top of the operand stack, and FP
to the base of the calleer save area, where the caller's FP is saved.
The second instruction set FP to the base of the template spill area.


-----------------------
incoming parameters
----------------------- 
caller's return address 
-----------------------
caller's FP        
----------------------- <-- FP (after enter)
template spill area
----------------------- <-- FP (after subq)
locals
----------------------- <-- -SP
stack <empty>
-----------------------


Incoming Parameters are address via FP, using positive offset;
local Java variables are addressed via FP using negative offset; 
Java stack slots via SP.

The JIT must compute the offset relative to FP of a local variable,
based on whether it is an incoming parameter. If it is, the offset is
at (caller saved area + stack slot * local index). Otherwise, the
offset is at (- template spill area - (1+local index) * stack slot).

On return, the callee remove its frame off the stack, include the
space on top of the caller's stack for incoming parameters. 

On AMD 64, this is done in the epilogue of the method in three steps: 

  // 1. adjust the frame pointer the base of the caller save area

  addq FP, <template spill area>

  // 2. pop the callee's frame, restore the caller's FP and set SP to
  // the location of the caller's return address on the stack

  leave

  // 3. Return and pop incoming parameter off the stack
  
  ret <incoming parameter area>

  
Returning of values is via a "return registers", following the
same convention as the optimizing compiler (a dedicated register
depending on the result kind).

It is the responsibility of the caller to push the result on the
operand stack. 

One benefit of this approach is the optimizing compiler needs no provisions at all 
to transform JIT method results, nor does the JIT need to special case
call from the optimizing compiler with respect to results.

Byte code implementations are generated by the optimizing compiler 
using a special template ABI that replaces SP by FP for most of the action.
They use the "template spill area" as an "embedded frame" inside the JIT frame,
referencing everything in there via FP.
(In this ABI, FP is removed from the pool of allocatable registers
that the register allocator can draw from during translation.)


1.2.2 Runtime call
-----------------

When a byte code implementation in JIT code calls a runtime method in the JVM,
this is different from calling an application method as prescribed by an invokeXXX bytecode.
The latter are generated by translating the special Call builtin.
The former are just regular calls, though affected by the special template ABI.

Because code produced by the optimizing compiler assume FP is a
callee-saved allocatable register, templates that are used for JIT
compilations must save and restore FP when performing runtime call. 
Thus, a runtime call from a template typically looks like:

push FP
call OPTIMIZED_ENTRY_POINT
pop FP

Note that the pushing of FP immediately before the call invalidates SP for the purpose of accessing stack parameters.
This is ok as long as no template runtime call actually expects any stack parameters,
i.e. all its parameters come in via registers.
Since we write all templates, this can be ensured
and it is also checked by the template generator.


2. Adapter frames
-----------------
The calling convention differs between the JIT and the optimizing
compiler. The former push the call arguments on the operand stack
according to the discipline described in the JVM specification,
whereas the latter passed most parameter in specific registers.

In order to support calls across code compiled by different compiler,
some massaging of the argument is needed. This is implemented using
adapter frame, which knows both calling convention and provides the
illusion of a caller following the same calling convention as the
callee. 

The design favors a solution that does not impact call from optmized
code to optimized code. 

Adapter frame code is located at method entry point:
- the adapter for Optimized-to-JIT code starts at optimized entry
point of the JIT method

- the adapter for the JIT-to-Optimized code starts at the JIT entry
point. This one having only 8 bytes of storage before the optimized
entry point typically start with jumping to a dedicated area at the
end of the optimized code.


2.1 Java call from Optimizing compiler to JIT
---------------------------------------------

The optimizing compiler needs to mimic the operand stack of the JIT
for passing parameter so that the entry point of the JIT is given the
illusion of being called from JIT-code. 

This is done by pushing arguments on top of the stack, before
calling the JIT entry point. The adapter frame doesn't need to 
pop the pushed argument off the stack as this is done by the callee
(according to jit calling convention). Further, nothing special needs
to be done for return values since the convention here is the same for
the two compilers: return value are passed by the same dedicated register
(according to the result's type).
So on return from the JIT entry point, all is needed is returning.

A typical adapter frame from optimized to JIT code looks as follows: 
 
 subq rsp, 0x10        // allocate space for adapter frame
 mov [rsp + 0], rsi    // push arguments according to JVM spec
 mov [rsp + 8], rdi    // 
 call JIT_ENTRY_POINT  // call JIT entry point
 ret                   // HERE, the arguments are already popped off the stack
                       // by the callee.

 The top of a stack after a optimized-to-jit call looks as follows:


 optimized frame
----------------------- ------+
caller's return address       | opt-jit adapter frame
-----------------------       | --------+ 
incoming parameters           |         |
-----------------------  -----+         |
caller's return address                 |
-----------------------                 |
caller's FP                             | callee frame
-----------------------                 |
template spill area                     |
----------------------- <-- FP          |
locals                                  |
----------------------- <-- SP   -------+
stack <empty>
----------------------- 


2.2. Java call from JIT to optimizing compiler
----------------------------------------------
 
  The JIT adapter needs to save and restore the caller frame pointer
  and prepare arguments according to the optimizing compiler's calling
  convention. It also needs to pop the incoming argument off the
  caller's operand stack to provide the caller the illusion of a JIT
  callee.

  On entering the JIT to optimized code frame adapter, the top of the
  stack is as follows


caller's template spill area
----------------------- <--- FP
caller's Java locals
-----------------------
caller's Java stack
-----------------------  
incoming parameters      
-----------------------  
caller's return address  
-----------------------  <--- SP

  Just before the frame adapter calls the optimized entry point, the
stack is as follows: 


caller's template spill area
----------------------- 
caller's Java locals
-----------------------
caller's Java stack
-----------------------         -------+
incoming parameters                    |
-----------------------                |
caller's return address                | jit-to-opt
-----------------------                | adapter frame.
caller's FP                            |
----------------------- <--- FP        |
<stack arguments, if any>              |
----------------------- <--- SP -------+


A typical adapter frame from optimized to JIT code looks as follows: 

 enter 0                                   // push FP
 mov rsi, [rsp + <caller save area + 0>]   // load arg0
 mov rdi, [rsp + <caller save area + 8>]   // load arg1
 call OPTIMIZED_ENTRY_POINT
 pop rbp                                   // restore caller's frame pointer
 ret  <arguments space>                    // return and pop incoming parameters off caller's stack


2.3. Runtime call from JIT to optimizing compiler
-------------------------------------------------

 No frame adapter is need for runtime call. Runtime calls are calls made
 from template compiled by the optimizing compiler to code compiled by
 the optmizing compiler. The boot image generator must guarantee that
 all runtime code are produced by the optimizing compiler. 


3. Trampoline frames
--------------------


4. Native frames
----------------

In general, we make no assumptions as to what languages are used for native code, 
how it's machine instructions are generated or 
what stack frame layout is used.
However, at the boundary between Java and the respective first frame outside Java
the ABI is well-defined: it is the C ABI on the given platform.

