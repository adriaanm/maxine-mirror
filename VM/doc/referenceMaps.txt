Every object referenced by an active thread is regarded as GC root.
This document describes all of the thread stack locations sought by GC root scanning.

The GC stops threads at safepoints to scan their references.
When a thread is stopped at a safepoint,
a stack reference map will be prepared
that indicates which slots on the thread stack contain object references.
This map is stored at the base address of the stack,
the stack pointer growing towards it.
The map is only used temporarily, during GC,
but it's space must stay reserved indefinitely,
because GC may occur at any safepoint,
i.e. for all purposes regarding where the stack pointer might be, at any time.

If the stopped thread's instruction pointer is in Java code,
the thread will prepare its own map itself, 
just before blocking.
If the thread is executing in native code,
the GC lets it continue and prepares the map on the thread's behalf.
In either case, map preparation precedes map scanning, i.e. root scanning.
This means that stack preparation may traverse object references
without having to take any modifications by the GC into account,
because these may only happen later.

Every stack slot that contains a reference is marked by a bit in the map.
The map represents the range between the stack top,
i.e. the last used stack pointer,
and the stack bottom, 
i.e. the last slot used by the VM,
which is at the end of LocalSpace, 
including the register save area.

The responsibilities for determining and representing what stack slots on a frame need to be marked are quite distributed.
The following lists them for all relevant combinations of caller->callee frame pairs and for different safepoint venues.

JIT->JIT
--------
Every JIT method contains a frame reference map that covers all areas of a JIT frame, 
including incoming parameters and excluding outgoing parameters.
The method's frame reference map may be computed on-the-fly as needed for stack reference map preparation,
using an algorithm that does not allocate from the object heap.

For safepoints, live references are recorded at the beginning of the respective bytecode 
that contains a safepoint and template spill slots are added at the safepoint.

For calls, live references are recorded at the end of the invocation byte code,
thus omitting the arguments on the expression stack.
The callee will cover these in its frame.
This is necessary, because the JVM spec allows the types of parameter slots
to be changed by the callee.


JIT->OPT
--------
The adapter frame code does not contain any safepoints.
The call in it can be ignored for stack scanning purposes,
because by the time it executed, all arguments will be where they belong in the optimized callee.
The callee can be treated as in OPT->OPT and the caller can now forget about its outgoing arguments.


JIT->OPT, downcall into runtime from a bytecode template
--------------------------------------------------------
In case of a call from within a bytecode implementation
that is given by a source code template
the callee always is an optimized method.

Here the outgoing arguments on the caller's expression stack are GC roots,
since we do not have the callee indicated by the invoke bytecode on the stack yet.
The abstract interpreter that creates the frame reference map takes this into account.
It generates mark bits for the parameters in this case
(in contrast to a call instruction at the very end of a bytecode implementation,
 to which the other JIT->XXX cases apply then,
 depending on what the callee turns out to be).


JIT->Trampoline
---------------
Due to its polymorphic nature, the trampoline does not contain any useful frame maps.
Hence, the outgoing arguments on the caller's expression stack are GC roots 
as long as there is no non-trampoline callee on the stack.
The mark bits for these arguments are inserted into the map 
while preparation traverses the caller,
knowing that its callee is a trampoline.


Trampoline->JIT
---------------
This should not occur, but if it did, it would count as OPT->JIT.


Trampoline->OPT
---------------
This does occur, and it counts as OPT->OPT.


OPT->OPT
--------
Both the caller and the callee each have frame reference maps 
that describe all stack slots on their frames,
except for the arguments passed between them.
Since arguments passed in stack slots reside in the caller's frame, 
map preparation for the caller is responsible for filling the mark bits for those in,
in addition to copying the respective frame reference map.


OPT->Trampoline
---------------
Due to its polymorphic nature, the trampoline does not contain any useful frame maps.
The mark bits for the arguments are inserted into the map 
while preparation traverses the caller,
knowing that its callee is a trampoline.

Where are the arguments?
From the caller's point of view some of them may reside in registers.
But those values are by then dead in the caller 
from the register allocator's perspective,
since we use a caller-saved regime for all registers.
To prolong their lifespan, 
the trampoline stores all potential parameters registers
in the canonical order defined by the target ABI on its stack,
starting from stack slot zero.
The compiler backend must make it so.

Then the stack reference map preparation algorithm can
mark map bits corresponding to these designated slots.
To determine which of the slots/parameters contain a reference,
the actual callee's signature is looked up and analyzed.

Before the trampoline returns it will restore all potential parameter registers to the values on its frame,
which by now have been scanned and updated by the GC.

Arguments passed in stack slots are already covered by the caller frame's preparation (see OPT->OPT).


OPT->JIT
--------
The adapter frame code will have pushed the arguments onto the stack before the callee gets control and stops.
The callee's preparation will then comprise dealing with the arguments (see JIT->JIT).


Safepoint in JIT code
---------------------
All the information from the top frame's reference maps applies.
In addition, the safepoint information from the template that contains the safepoint applies.
Describing the latter is covered by the next topic.


Safepoint in OPT code
---------------------
The top frame's method contains a frame reference map for all stack slots in the frame.
In addition, since this is the top frame,
registers need to be saved, scanned and restored.
The method also contains a register reference map for this purpose.


Safepoint in trampoline
-----------------------
Same as safepoint in OPT code.
