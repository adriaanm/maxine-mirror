/*
 * Copyright (c) 2009 Sun Microsystems, Inc.  All rights reserved.
 *
 * Sun Microsystems, Inc. has intellectual property rights relating to technology embodied in the product
 * that is described in this document. In particular, and without limitation, these intellectual property
 * rights may include one or more of the U.S. patents listed at http://www.sun.com/patents and one or
 * more additional patents or pending patent applications in the U.S. and in other countries.
 *
 * U.S. Government Rights - Commercial software. Government users are subject to the Sun
 * Microsystems, Inc. standard license agreement and applicable provisions of the FAR and its
 * supplements.
 *
 * Use is subject to license terms. Sun, Sun Microsystems, the Sun logo, Java and Solaris are trademarks or
 * registered trademarks of Sun Microsystems, Inc. in the U.S. and other countries. All SPARC trademarks
 * are used under license and are trademarks or registered trademarks of SPARC International, Inc. in the
 * U.S. and other countries.
 *
 * UNIX is a registered trademark in the U.S. and other countries, exclusively licensed through X/Open
 * Company, Ltd.
 */
package com.sun.max.vm.stack;

import static com.sun.max.vm.compiler.target.TargetMethod.Flavor.*;

import com.sun.max.unsafe.*;
import com.sun.max.vm.actor.member.*;
import com.sun.max.vm.bytecode.*;
import com.sun.max.vm.compiler.target.*;
import com.sun.max.vm.jni.*;
import com.sun.max.vm.reflection.*;
import com.sun.max.vm.stack.StackFrameWalker.Cursor;
import com.sun.max.vm.thread.*;

/**
 * Utility for iterating over the source method frames (or 'vframes' in HotSpot terminology)
 * of a call stack. In this context, a source method is a <i>bytecode method</i> (which
 * may or may not have been compiled from Java source code) either loaded by the VM
 * from a class file or generated by the VM (e.g. a {@linkplain NativeStubGenerator native
 * method stub} or a {@linkplain InvocationStubGenerator reflection invocation stub}).
 *
 * @author Doug Simon
 */
public class SourceFrameVisitor extends RawStackFrameVisitor {

    public SourceFrameVisitor() {
    }

    /**
     * Iterates over a given stack, calling {@link #visitSourceFrame(ClassMethodActor, int, boolean, long)}
     * for each source method with an activation frame on the stack.
     */
    public void walk(StackFrameWalker walker, Pointer ip, Pointer sp, Pointer fp) {
        if (walker == null) {
            walker = new VmStackFrameWalker(VmThread.current().tla());
        }
        walker.inspect(ip, sp, fp, this);
    }

    @Override
    public boolean visitFrame(Cursor current, Cursor callee) {
        final TargetMethod targetMethod = current.targetMethod;
        if (targetMethod == null) {
            visitNativeFrame(current.ip.toLong());
            return true;
        }
        if (!targetMethod.isCompiled()) {
            // ignore stubs, trampolines, adapters etc
            return true;
        }

        long frameId = current.sp.toLong() << 16;
        BytecodeLocation bytecodeLocation = targetMethod.getBytecodeLocationFor(current.ip(), current.ipIsReturnAddress);
        boolean trapped = callee.targetMethod != null && callee.targetMethod.is(TrapStub);
        if (bytecodeLocation == null) {
            return visitSourceFrame(targetMethod.classMethodActor, -1, trapped, frameId);
        }
        return visitSourceFrames(bytecodeLocation, trapped, frameId);
    }

    private boolean visitSourceFrames(BytecodeLocation bytecodeLocation, boolean trapped, long frameId) {
        if (!visitSourceFrame(bytecodeLocation.classMethodActor, bytecodeLocation.bytecodePosition, trapped, frameId)) {
            return false;
        }
        if (bytecodeLocation.parent() != null) {
            return visitSourceFrames(bytecodeLocation.parent(), false, ++frameId);
        }
        return true;
    }

    /**
     * Notifies this object of a source method frame being traversed.
     *
     * @param method a source method on the stack
     * @param bci the bytecode index of the execution point within the method (or -1 if not available)
     * @param trapped specifies if execution is stopped in {@code method} at a trap
     * @param frameId a unique identifier for this activation of the method. This value is only valid while the method
     *            activation is on the stack.
     * @return {@code true} if the stack walk should continue
     */
    public boolean visitSourceFrame(ClassMethodActor method, int bci, boolean trapped, long frameId) {
        return true;
    }

    /**
     * Notifies this object of one or more native/C functions being traversed.
     *
     * @param frameId a unique identifier for the set of native/C functions frames
     * @return {@code true} if the stack walk should continue
     */
    public boolean visitNativeFrame(long frameId) {
        return true;
    }
}
