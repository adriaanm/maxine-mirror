/*
 * Copyright (c) 2007 Sun Microsystems, Inc.  All rights reserved.
 *
 * Sun Microsystems, Inc. has intellectual property rights relating to technology embodied in the product
 * that is described in this document. In particular, and without limitation, these intellectual property
 * rights may include one or more of the U.S. patents listed at http://www.sun.com/patents and one or
 * more additional patents or pending patent applications in the U.S. and in other countries.
 *
 * U.S. Government Rights - Commercial software. Government users are subject to the Sun
 * Microsystems, Inc. standard license agreement and applicable provisions of the FAR and its
 * supplements.
 *
 * Use is subject to license terms. Sun, Sun Microsystems, the Sun logo, Java and Solaris are trademarks or
 * registered trademarks of Sun Microsystems, Inc. in the U.S. and other countries. All SPARC trademarks
 * are used under license and are trademarks or registered trademarks of SPARC International, Inc. in the
 * U.S. and other countries.
 *
 * UNIX is a registered trademark in the U.S. and other countries, exclusively licensed through X/Open
 * Company, Ltd.
 */
/*VCSID=1d31a04c-89b8-42fb-9c91-5d23b0080fe5*/
package com.sun.max.vm.debug;

import java.io.*;

import com.sun.max.annotate.*;
import com.sun.max.memory.*;
import com.sun.max.unsafe.*;
import com.sun.max.vm.*;
import com.sun.max.vm.actor.member.*;
import com.sun.max.vm.runtime.*;
import com.sun.max.vm.thread.*;

/**
 * This class contains debugging utilities, in particular, "out" and "err" print streams that
 * go directly to native code (e.g. C-style printf) and thus provide a quicker way of producing
 * output that depends on fewer VM features, and is thus useful for debugging lower-level primitives.
 *
 * @author Ben L. Titzer
 * @author Doug Simon
 */
public final class Debug {

    private Debug() {
    }

    static {
        new CriticalNativeMethod(Debug.class, "debug_lock");
        new CriticalNativeMethod(Debug.class, "debug_unlock");

        new CriticalNativeMethod(Debug.class, "debug_print_buffer");
        new CriticalNativeMethod(Debug.class, "debug_print_boolean");
        new CriticalNativeMethod(Debug.class, "debug_print_char");
        new CriticalNativeMethod(Debug.class, "debug_print_int");
        new CriticalNativeMethod(Debug.class, "debug_print_long");
        new CriticalNativeMethod(Debug.class, "debug_print_float");
        new CriticalNativeMethod(Debug.class, "debug_print_double");
        new CriticalNativeMethod(Debug.class, "debug_print_word");
        new CriticalNativeMethod(Debug.class, "debug_print_newline");
    }

    @C_FUNCTION
    private static native void debug_print_buffer(int fileDescriptor, Address val);

    @C_FUNCTION
    private static native void debug_print_boolean(int fileDescriptor, boolean val);

    @C_FUNCTION
    private static native void debug_print_char(int fileDescriptor, int val);

    @C_FUNCTION
    private static native void debug_print_int(int fileDescriptor, int val);

    @C_FUNCTION
    private static native void debug_print_long(int fileDescriptor, long val);

    @C_FUNCTION
    private static native void debug_print_float(int fileDescriptor, float val);

    @C_FUNCTION
    private static native void debug_print_double(int fileDescriptor, double val);

    @C_FUNCTION
    private static native void debug_print_word(int fileDescriptor, Word val);

    @C_FUNCTION
    private static native void debug_print_newline(int fileDescriptor);

    @C_FUNCTION
    private static native void debug_lock();

    @C_FUNCTION
    private static native void debug_unlock();

    protected static final int STDOUT = 1;
    protected static final int STDERR = 2;
    protected static final int LOGFILE = -1;

    /**
     * The low level print stream to be used for writing output that is under the control of VM
     * {@linkplain VMOptions command line arguments}. This output is sent to the console's
     * standard output stream. Ideally, all output generated by command line arguments that request
     * some kind of verbose tracing use this print stream. That is, if no such arguments are present,
     * then only application generated output are sent to the console's standard
     * output stream.
     */
    public static final DebugPrintStream out = new DebugPrintStream(new DebugOutputStream(STDOUT));

    /**
     * The low level print stream to be used for fatal VM error messages (e.g. Stack overflow in native code detected).
     * including the usage message shown when invalid VM {@linkplain VMOptions command line arguments} are
     * specified on the VM command line.
     */
    public static final DebugPrintStream err = new DebugPrintStream(new DebugOutputStream(STDERR));

    /**
     * The low level print stream to be used for writing output that is not controlled by
     * VM {@linkplain VMOptions command line arguments}. This output is sent to
     * a log file and does not show up on the console.
     */
    public static final DebugPrintStream log = new DebugPrintStream(new DebugOutputStream(LOGFILE));

    /**
     * Equivalent to calling the {@link DebugPrintStream#print(String)} on the {@link #log} stream.
     */
    public static void print(String s) {
        log.print(s);
    }

    /**
     * Equivalent to calling the {@link DebugPrintStream#print(int)} on the {@link #log} stream.
     */
    public static void print(int i) {
        log.print(i);
    }

    /**
     * Equivalent to calling the {@link DebugPrintStream#print(long)} on the {@link #log} stream.
     */
    public static void print(long i) {
        log.print(i);
    }

    /**
     * Equivalent to calling the {@link DebugPrintStream#print(char)} on the {@link #log} stream.
     */
    public static void print(char c) {
        log.print(c);
    }

    /**
     * Equivalent to calling the {@link DebugPrintStream#print(boolean))} on the {@link #log} stream.
     */
    public static void print(boolean b) {
        log.print(b);
    }

    /**
     * Equivalent to calling the {@link DebugPrintStream#print(double)} on the {@link #log} stream.
     */
    public static void print(double d) {
        log.print(d);
    }

    /**
     * Equivalent to calling the {@link DebugPrintStream#print(float)} on the {@link #log} stream.
     */
    public static void print(float f) {
        log.print(f);
    }

    /**
     * Equivalent to calling the {@link DebugPrintStream#print(char[])} on the {@link #log} stream.
     */
    public static void print(char[] c) {
        log.print(c);
    }

    /**
     * Equivalent to calling the {@link DebugPrintStream#print(Word)} on the {@link #log} stream.
     */
    public static void print(Word word) {
        log.print(word);
    }

    /**
     * Equivalent to calling the {@link DebugPrintStream#println(String)} on the {@link #log} stream.
     */
    public static void println(String s) {
        log.println(s);
    }

    /**
     * Equivalent to calling the {@link DebugPrintStream#println()} on the {@link #log} stream.
     */
    public static void println() {
        log.println();
    }

    /**
     * Equivalent to calling the {@link DebugPrintStream#println(int)} on the {@link #log} stream.
     */
    public static void println(int i) {
        log.println(i);
    }

    /**
     * Equivalent to calling the {@link DebugPrintStream#println(long)} on the {@link #log} stream.
     */
    public static void println(long i) {
        log.println(i);
    }

    /**
     * Equivalent to calling the {@link DebugPrintStream#println(char)} on the {@link #log} stream.
     */
    public static void println(char c) {
        log.println(c);
    }

    /**
     * Equivalent to calling the {@link DebugPrintStream#println(boolean)} on the {@link #log} stream.
     */
    public static void println(boolean b) {
        log.println(b);
    }

    /**
     * Equivalent to calling the {@link DebugPrintStream#println(double)} on the {@link #log} stream.
     */
    public static void println(double d) {
        log.println(d);
    }

    /**
     * Equivalent to calling the {@link DebugPrintStream#println(float)} on the {@link #log} stream.
     */
    public static void println(float f) {
        log.println(f);
    }

    /**
     * Equivalent to calling the {@link DebugPrintStream#println(char[])} on the {@link #log} stream.
     */
    public static void println(char[] c) {
        log.println(c);
    }

    /**
     * Equivalent to calling the {@link DebugPrintStream#println(Word)} on the {@link #log} stream.
     */
    public static void println(Word word) {
        log.println(word);
    }

    public static final class DebugOutputStream extends OutputStream {
        private final int _fileDescriptor;
        private DebugOutputStream(int fd) {
            _fileDescriptor = fd;
        }
        @Override
        public void write(int b) {
            if (MaxineVM.isPrototyping()) {
                if (_fileDescriptor == STDOUT) {
                    System.out.write(b);
                } else {
                    System.err.write(b);
                }
            } else {
                debug_print_char(_fileDescriptor, b);
            }
        }

        @Override
        public void write(byte[] b, int off, int len) throws IOException {
            if (MaxineVM.isPrototyping()) {
                if (_fileDescriptor == STDOUT) {
                    System.out.write(b, off, len);
                } else {
                    System.err.write(b, off, len);
                }
            } else {
                final boolean lockDisabledSafepoints = Debug.lock();
                final Pointer buffer = BootMemory.buffer();
                final int bufferSize = BootMemory.bufferSize();
                int i = off;
                final int end = off + len;
                while (i < end) {
                    i = CString.writeBytes(b, i, end, buffer, bufferSize);
                    debug_print_buffer(_fileDescriptor, buffer);
                }
                Debug.unlock(lockDisabledSafepoints);
            }
        }
    }

    /**
     * Convenience routine for printing a FieldActor to a given DebugPrintStream. The output is of the form:
     *
     * <pre>
     *     &lt;name&gt;:&lt;descriptor&gt; in &lt;holder&gt;
     * </pre>
     *
     * For example, the output for {@link System#err} is:
     *
     * <pre>
     * &quot;err:Ljava/io/PrintStream; in java.lang.System&quot;
     * </pre>
     *
     * @param stream the stream to which a representation of {@code fieldActor} will be printed
     * @param fieldActor the field actor to print
     * @param withNewline specifies if a newline should be appended to the stream after the field actor
     */
    public static void printFieldActor(DebugPrintStream stream, FieldActor fieldActor, boolean withNewline) {
        boolean lockDisabledSafepoints = false;
        if (!MaxineVM.isPrototyping()) {
            lockDisabledSafepoints = lock();
        }
        stream.print(fieldActor.name().string());
        stream.print(":");
        stream.print(fieldActor.descriptor().string());
        stream.print(" in ");
        stream.print(fieldActor.holder().name().string(), withNewline);
        if (!MaxineVM.isPrototyping()) {
            unlock(lockDisabledSafepoints);
        }
    }

    /**
     * Convenience routine for printing a MethodActor to a given DebugPrintStream. The output is of the form:
     *
     * <pre>
     *     &lt;name&gt;&lt;descriptor&gt; in &lt;holder&gt;
     * </pre>
     *
     * For example, the output for {@link Runnable#run()} is:
     *
     * <pre>
     * &quot;run()V in java.lang.Runnable&quot;
     * </pre>
     *
     * @param stream the stream to which a representation of {@code fieldActor} will be printed
     * @param methodActor the method actor to print
     * @param withNewline specifies if a newline should be appended to the stream after the method actor
     */
    public static void printMethodActor(DebugPrintStream stream, MethodActor methodActor, boolean withNewline) {
        boolean lockDisabledSafepoints = false;
        if (!MaxineVM.isPrototyping()) {
            lockDisabledSafepoints = lock();
        }
        stream.print(methodActor.name().string());
        stream.print(methodActor.descriptor().string());
        stream.print(" in ");
        stream.print(methodActor.holder().name().string(), withNewline);
        if (!MaxineVM.isPrototyping()) {
            unlock(lockDisabledSafepoints);
        }
    }

    /**
     * Convenience routine for printing a {@link VmThread} to a given DebugPrintStream. The output is of the form:
     *
     * <pre>
     *     &lt;name&gt;[&lt;id&gt;]
     * </pre>
     *
     * For example, the output for the main thread of execution may be:
     *
     * <pre>
     * &quot;main[id=1]&quot;
     * </pre>
     *
     * @param stream the stream to which a representation of {@code fieldActor} will be printed
     * @param vmThread the thread to print
     * @param withNewline specifies if a newline should be appended to the stream after the thread
     */
    public static void printVmThread(DebugPrintStream stream, VmThread vmThread, boolean withNewline) {
        boolean lockDisabledSafepoints = false;
        if (!MaxineVM.isPrototyping()) {
            lockDisabledSafepoints = lock();
        }
        stream.print(vmThread.getName());
        stream.print("[id=");
        stream.print(vmThread.id());
        stream.print("]", withNewline);
        if (!MaxineVM.isPrototyping()) {
            unlock(lockDisabledSafepoints);
        }
    }

    public static final class DebugPrintStream extends PrintStream {
        private final int _fileDescriptor;
        private DebugPrintStream(DebugOutputStream output) {
            super(output);
            _fileDescriptor = output._fileDescriptor;
        }

        public void print(String s, boolean withNewline) {
            if (withNewline) {
                println(s);
            } else {
                print(s);
            }
        }
        @Override
        public void print(String s) {
            if (MaxineVM.isPrototyping()) {
                super.print(s);
            } else {
                final boolean lockDisabledSafepoints = Debug.lock();
                printString(s);
                Debug.unlock(lockDisabledSafepoints);
            }
        }
        @Override
        public void print(int i) {
            if (MaxineVM.isPrototyping()) {
                super.print(i);
            } else {
                // locking is not really necessary for primitives
                debug_print_int(_fileDescriptor, i);
            }
        }
        @Override
        public void print(long i) {
            if (MaxineVM.isPrototyping()) {
                super.print(i);
            } else {
                // locking is not really necessary for primitives
                debug_print_long(_fileDescriptor, i);
            }
        }
        @Override
        public void print(char c) {
            if (MaxineVM.isPrototyping()) {
                super.print(c);
            } else {
                // locking is not really necessary for primitives
                debug_print_char(_fileDescriptor, c);
            }
        }
        @Override
        public void print(boolean b) {
            if (MaxineVM.isPrototyping()) {
                super.print(b);
            } else {
                // locking is not really necessary for primitives
                debug_print_boolean(_fileDescriptor, b);
            }
        }
        @Override
        public void print(double d) {
            if (MaxineVM.isPrototyping()) {
                super.print(d);
            } else {
                // locking is not really necessary for primitives
                debug_print_double(_fileDescriptor, d);
            }
        }
        @Override
        public void print(float f) {
            if (MaxineVM.isPrototyping()) {
                super.print(f);
            } else {
                // locking is not really necessary for primitives
                debug_print_float(_fileDescriptor, f);
            }
        }
        @Override
        public void print(char[] c) {
            if (MaxineVM.isPrototyping()) {
                super.print(c);
            } else {
                final boolean lockDisabledSafepoints = Debug.lock();
                printChars(c);
                Debug.unlock(lockDisabledSafepoints);
            }
        }
        public void print(Word word) {
            if (MaxineVM.isPrototyping()) {
                super.print(word.toHexString());
            } else {
                // locking is not really necessary for primitives
                debug_print_word(_fileDescriptor, word);
            }
        }
        @Override
        public void println(String s) {
            if (MaxineVM.isPrototyping()) {
                super.println(s);
            } else {
                final boolean lockDisabledSafepoints = Debug.lock();
                printString(s);
                debug_print_newline(_fileDescriptor);
                Debug.unlock(lockDisabledSafepoints);
            }
        }
        @Override
        public void println() {
            if (MaxineVM.isPrototyping()) {
                super.println();
            } else {
                final boolean lockDisabledSafepoints = Debug.lock();
                debug_print_newline(_fileDescriptor);
                Debug.unlock(lockDisabledSafepoints);
            }
        }
        @Override
        public void println(int i) {
            if (MaxineVM.isPrototyping()) {
                super.println(i);
            } else {
                final boolean lockDisabledSafepoints = Debug.lock();
                debug_print_int(_fileDescriptor, i);
                debug_print_newline(_fileDescriptor);
                Debug.unlock(lockDisabledSafepoints);
            }
        }
        @Override
        public void println(long i) {
            if (MaxineVM.isPrototyping()) {
                super.println(i);
            } else {
                final boolean lockDisabledSafepoints = Debug.lock();
                debug_print_long(_fileDescriptor, i);
                debug_print_newline(_fileDescriptor);
                Debug.unlock(lockDisabledSafepoints);
            }
        }
        @Override
        public void println(char c) {
            if (MaxineVM.isPrototyping()) {
                super.println(c);
            } else {
                final boolean lockDisabledSafepoints = Debug.lock();
                debug_print_char(_fileDescriptor, c);
                debug_print_newline(_fileDescriptor);
                Debug.unlock(lockDisabledSafepoints);
            }
        }
        @Override
        public void println(boolean b) {
            if (MaxineVM.isPrototyping()) {
                super.println(b);
            } else {
                final boolean lockDisabledSafepoints = Debug.lock();
                debug_print_boolean(_fileDescriptor, b);
                debug_print_newline(_fileDescriptor);
                Debug.unlock(lockDisabledSafepoints);
            }
        }
        @Override
        public void println(double d) {
            if (MaxineVM.isPrototyping()) {
                super.println(d);
            } else {
                final boolean lockDisabledSafepoints = Debug.lock();
                debug_print_double(_fileDescriptor, d);
                debug_print_newline(_fileDescriptor);
                Debug.unlock(lockDisabledSafepoints);
            }
        }
        @Override
        public void println(float f) {
            if (MaxineVM.isPrototyping()) {
                super.println(f);
            } else {
                final boolean lockDisabledSafepoints = Debug.lock();
                debug_print_float(_fileDescriptor, f);
                debug_print_newline(_fileDescriptor);
                Debug.unlock(lockDisabledSafepoints);
            }
        }
        @Override
        public void println(char[] c) {
            if (MaxineVM.isPrototyping()) {
                super.println(c);
            } else {
                final boolean lockDisabledSafepoints = Debug.lock();
                printChars(c);
                debug_print_newline(_fileDescriptor);
                Debug.unlock(lockDisabledSafepoints);
            }
        }
        public void println(Word word) {
            if (MaxineVM.isPrototyping()) {
                super.println(word.toHexString());
            } else {
                final boolean lockDisabledSafepoints = Debug.lock();
                debug_print_word(_fileDescriptor, word);
                debug_print_newline(_fileDescriptor);
                Debug.unlock(lockDisabledSafepoints);
            }
        }

        private void printString(String string) {
            final String s = string == null ? "null" : string;
            final Pointer buffer = BootMemory.buffer();
            final int bufferSize = BootMemory.bufferSize();
            int i = 0;
            while (i < s.length()) {
                i = CString.writePartialUtf8(s, i, buffer, bufferSize);
                debug_print_buffer(_fileDescriptor, buffer);
            }
        }

        private void printChars(char[] ch) {
            final Pointer buffer = BootMemory.buffer();
            final int bufferSize = BootMemory.bufferSize();
            int i = 0;
            while (i < ch.length) {
                i = CString.writePartialUtf8(ch, i, buffer, bufferSize);
                debug_print_buffer(_fileDescriptor, buffer);
            }
        }
    }

    /**
     * Attempts to acquire the global lock on all debug output, blocking until the lock is successfully acquired. This
     * lock can be acquired recursively by a thread. The lock is not released for other threads until the thread that
     * owns the lock calls {@link #unlock} the same number of times it called this method.
     *
     * This method ensures that safepoints are disabled before it returns.
     *
     * @return true if this call caused safepoints to be disabled (i.e. they were enabled upon entry to this method).
     *         This value must be passed to the paired call to {@link #unlock} so that safepoints are restored to the
     *         appropriate state (i.e. the state they had before the sequence of code protected by this lock was
     *         entered).
     */
    public static boolean lock() {
        final boolean safepointsDisabled = Safepoint.isDisabled();
        if (!safepointsDisabled) {
            Safepoint.disable();
        }
        Debug.debug_lock();
        return !safepointsDisabled;
    }

    /**
     * Attempts to releases the global lock on all debug output. This must only be called by a thread that currently
     * owns the lock - failure to do so causes the VM to exit. The lock is not released for other threads until this
     * method is called the same number of times as {@link #lock()} was called when acquiring the lock.
     *
     * @param lockDisabledSafepoints specifies if the adjoining call to {@link #lock()} disabled safepoints. If so, then
     *            this call will re-enable them.
     */
    public static void unlock(boolean lockDisabledSafepoints) {
        Debug.debug_unlock();
        FatalError.check(Safepoint.isDisabled(), "Safepoints must not be re-enabled in code surrounded by Debug.lock() and Debug.unlock()");
        if (lockDisabledSafepoints) {
            Safepoint.enable();
        }
    }
}
