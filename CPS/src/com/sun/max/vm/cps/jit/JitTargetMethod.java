/*
 * Copyright (c) 2007, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.max.vm.cps.jit;

import static com.sun.max.platform.Platform.*;

import java.util.*;

import com.sun.cri.ci.*;
import com.sun.max.annotate.*;
import com.sun.max.atomic.*;
import com.sun.max.unsafe.*;
import com.sun.max.vm.*;
import com.sun.max.vm.actor.member.*;
import com.sun.max.vm.bytecode.*;
import com.sun.max.vm.bytecode.refmaps.*;
import com.sun.max.vm.collect.*;
import com.sun.max.vm.compiler.*;
import com.sun.max.vm.compiler.builtin.*;
import com.sun.max.vm.compiler.target.*;
import com.sun.max.vm.cps.target.*;
import com.sun.max.vm.runtime.*;
import com.sun.max.vm.stack.*;

/**
 * A target method generated by the JIT.
 *
 * @author Laurent Daynes
 * @author Bernd Mathiske
 * @author Doug Simon
 */
public abstract class JitTargetMethod extends CPSTargetMethod {

    protected int frameReferenceMapOffset;

    private final AtomicReference referenceMapEditor = new AtomicReference();

    /**
     * The stack frame layout object is required by {@link StackReferenceMapPreparer#prepareTrampolineFrameForJITCaller}.
     */
    private JVMSFrameLayout stackFrameLayout;

    /**
     * A bit map denoting which {@linkplain #directCallees() direct calls} in this target method correspond to calls
     * into the runtime derived from the constituent templates. These calls are
     * {@linkplain #linkDirectCalls(Adapter) linked} using the entry point associated with the compiler
     * used to compile the runtime (i.e the opto compiler). All other direct calls are linked using the call entry point
     * associated with the JIT compiler.
     */
    private byte[] isDirectCallToRuntime;

    /**
     * An array that encodes a mapping from bytecode positions to target code positions. A non-zero value
     * {@code val} at index {@code i} in the array encodes that there is a bytecode instruction whose opcode is at index
     * {@code i} in the bytecode array and whose target code position is {@code val}. Unless {@code i} is equal to the
     * length of the bytecode array in which case {@code val} denotes the target code position one byte past the
     * last target code byte emitted for the last bytecode instruction.
     */
    private int[] bciToPosMap;

    protected JitTargetMethod(ClassMethodActor classMethodActor) {
        super(classMethodActor, CallEntryPoint.JIT_ENTRY_POINT);
    }

    @Override
    public int[] bciToPosMap() {
        return bciToPosMap;
    }

    public int sizeOfNonParameterLocals() {
        return JVMSFrameLayout.JVMS_SLOT_SIZE * (classMethodActor.codeAttribute().maxLocals - classMethodActor.numberOfParameterSlots());
    }

    public int sizeOfParameters() {
        return classMethodActor.numberOfParameterSlots() * JVMSFrameLayout.JVMS_SLOT_SIZE;
    }

    @HOSTED_ONLY
    @Override
    public void gatherCalls(Set<MethodActor> directCalls, Set<MethodActor> virtualCalls, Set<MethodActor> interfaceCalls, Set<MethodActor> inlinedMethods) {
        final BytecodeVisitor bytecodeVisitor = new InvokedMethodRecorder(classMethodActor, directCalls, virtualCalls, interfaceCalls);
        final BytecodeScanner bytecodeScanner = new BytecodeScanner(bytecodeVisitor);
        bytecodeScanner.scan(classMethodActor);
    }

    @Override
    protected CallEntryPoint callEntryPointForDirectCall(int directCallIndex) {
        if (isDirectCallToRuntime != null && ByteArrayBitMap.isSet(isDirectCallToRuntime, 0, isDirectCallToRuntime.length, directCallIndex)) {
            return CallEntryPoint.OPTIMIZED_ENTRY_POINT;
        }
        return super.callEntryPointForDirectCall(directCallIndex);
    }

    @HOSTED_ONLY
    @Override
    protected boolean isDirectCalleeInPrologue(int directCalleeIndex) {
        return stopPosition(directCalleeIndex) < targetCodePositionFor(0);
    }

    public int targetCodePositionFor(int bytecodePosition) {
        return bciToPosMap[bytecodePosition];
    }

    @Override
    public CiFrame getBytecodeFrames(int stopIndex) {
        int bci = bciFor(stopPosition(stopIndex));
        return stackFrameLayout.asFrame(classMethodActor, bci);
    }

    @Override
    public CiCodePos getCodePos(Pointer ip, boolean ipIsReturnAddress) {
        if (ipIsReturnAddress && platform().isa.offsetToReturnPC == 0) {
            ip = ip.minus(1);
        }
        int bci = bciFor(ip.asPointer());
        return new CiCodePos(null, classMethodActor, bci);
    }

    /**
     * Gets the bytecode position for a machine code instruction address.
     *
     * @param instructionPointer an instruction pointer that may denote an instruction in this target method
     * @return the start position of the bytecode instruction that is implemented at the instruction pointer or -1 if
     *         {@code instructionPointer} denotes an instruction that does not correlate to any bytecode.  This will be
     *         the case when {@code instructionPointer} is not in this target method or is in the adapter frame stub
     *         code, prologue or epilogue.
     */
    public int bciFor(Pointer instructionPointer) {
        assert bciToPosMap != null;
        assert bciToPosMap.length > 0;
        final int targetCodePosition = posFor(instructionPointer);
        return bciFor(targetCodePosition);
    }

    /**
     * This method is guaranteed not to perform allocation.
     */
    @Override
    public final JVMSFrameLayout stackFrameLayout() {
        if (stackFrameLayout == null) {
            FatalError.unexpected("Cannot get JIT stack frame layout for incomplete JIT method");
        }
        return stackFrameLayout;
    }

    /**
     * Gets the bytecode position for a target code position in this JIT target method.
     *
     * @param targetCodePosition a target code position that may denote an instruction in this target method that correlates with a
     *                           bytecode
     * @return the start position of the bytecode instruction that is implemented at {@code targetCodePosition} or -1 if
     *         {@code targetCodePosition} is outside the range(s) of target code positions in this target method that
     *         correlate with a bytecode.
     */
    public int bciFor(int targetCodePosition) {
        assert bciToPosMap != null;
        assert bciToPosMap.length > 0;
        int bytecodePosition;
        if (targetCodePosition >= targetCodePositionFor(0)) {
            bytecodePosition = -1;
            // Search the map backwards as there may be bytecodes for which
            // no target code was emitted. The search is for the first bytecode
            // position that maps to a non-zero target code position less than or
            // equal to 'targetCodePosition'
            for (int i = bciToPosMap.length - 1; i >= 0; --i) {
                int pos = targetCodePositionFor(i);
                if (pos != 0) {
                    if (pos <= targetCodePosition) {
                        // This is the first bytecode that maps to a non-zero target
                        // code position less than or equal to 'targetCodePosition'
                        bytecodePosition = i;
                        break;
                    }
                }
            }
            assert bytecodePosition >= 0;
            return bytecodePosition;
        }
        // The instruction pointer denotes a position in the adapter frame code or the prologue
        return -1;
    }

    public final void setGenerated(
            int[] catchRangePositions,
            int[] catchBlockPositions,
            int[] stopPositions,
            BytecodeStopsIterator bytecodeStopsIterator,
            byte[] compressedJavaFrameDescriptors,
            ClassMethodActor[] directCallees,
            int numberOfIndirectCalls,
            int numberOfSafepoints,
            byte[] referenceMaps,
            byte[] scalarLiteralBytes,
            Object[] referenceLiterals,
            byte[] codeBuffer,
            byte[] encodedInlineDataDescriptors,
            ByteArrayBitMap isDirectRuntimeCall,
            int[] bytecodeToTargetCodePositionMap,
            int numberOfBlocks,
            boolean[] blockStarts,
            JVMSFrameLayout jitStackFrameLayout,
            TargetABI abi) {
        setGenerated(
                catchRangePositions,
                catchBlockPositions,
                stopPositions,
                compressedJavaFrameDescriptors,
                directCallees,
                numberOfIndirectCalls,
                numberOfSafepoints,
                referenceMaps,
                scalarLiteralBytes,
                referenceLiterals,
                codeBuffer,
                encodedInlineDataDescriptors,
                jitStackFrameLayout.frameSize(),
                jitStackFrameLayout.frameReferenceMapSize()
        );
        this.isDirectCallToRuntime = isDirectRuntimeCall == null ? null : isDirectRuntimeCall.bytes();
        this.bciToPosMap = bytecodeToTargetCodePositionMap;
        this.frameReferenceMapOffset = jitStackFrameLayout.frameReferenceMapOffset();
        this.stackFrameLayout = jitStackFrameLayout;
        if (stopPositions != null) {
            final JitReferenceMapEditor referenceMapEditor = new JitReferenceMapEditor(this, numberOfBlocks, blockStarts, bytecodeStopsIterator, jitStackFrameLayout);
            this.referenceMapEditor.set(referenceMapEditor);
            final ReferenceMapInterpreter interpreter = ReferenceMapInterpreter.from(referenceMapEditor.blockFrames());
            if (interpreter.performsAllocation() || MaxineVM.isHosted()) {
                // if computing the reference map requires allocation or if bootstrapping,
                // compute the reference map now
                finalizeReferenceMaps();
            }
        }
    }

    /**
     * Ensures that the {@linkplain #referenceMaps() reference maps} for this JIT target method are finalized. Only
     * finalized reference maps are guaranteed to never change for the remaining lifetime of this target method.
     * <p/>
     * Although this method may be called by multiple threads, it cannot use standard synchronization as that may block
     * one of the threads in native code on a mutex. This would incorrectly be interpreted by the GC as meaning
     * the mutator thread has blocked for GC after taking a safepoint trap. To avoid blocking in native code,
     * a spin loop is used instead.
     * <p/>
     * If this method is called while preparing the stack reference map for a thread that has taken a safepoint
     * for GC, then safepoints are currently disabled and so there is no need to use the {@link NO_SAFEPOINTS}
     * annotation on this method.
     */
    public void finalizeReferenceMaps() {
        final JitReferenceMapEditor referenceMapEditor = (JitReferenceMapEditor) this.referenceMapEditor.get();
        if (referenceMapEditor != null) {
            final Object result = this.referenceMapEditor.compareAndSwap(referenceMapEditor, JitReferenceMapEditor.SENTINEL);
            if (result == JitReferenceMapEditor.SENTINEL) {
                while (this.referenceMapEditor.get() != null) {
                    SpecialBuiltin.pause();
                }
            } else if (result != null) {
                referenceMapEditor.fillInMaps();
                this.referenceMapEditor.set(null);
            }
        }
    }

    @Override
    public boolean preserveRegistersForLocalExceptionHandler() {
        return false;
    }
}
