package com.sun.max.vm.jvmti;

import java.io.*;

import com.sun.max.annotate.*;
import com.sun.max.ide.*;
import com.sun.max.io.*;
import com.sun.max.unsafe.Address;
import com.sun.max.vm.runtime.*;


public class JDWPSymbols {

    private static class Info {
        String name;
        Address value;
        int length;

        Info(String name, long offset) {
            this.name = name;
            this.value = Address.fromLong(offset);
        }

    }

    private static Info[] map;
    private static int index;
    private static int onLoadIndex;

// START GENERATED CODE
    @HOSTED_ONLY
    private static void initializeMap() {
        map[index++] = new Info("length", 0x9dd0L);
        map[index++] = new Info("newComponents", 0x9e80L);
        map[index++] = new Info("deleteComponents", 0x9ee0L);
        map[index++] = new Info("writeBooleanComponents", 0x9ef0L);
        map[index++] = new Info("writeByteComponents", 0xa120L);
        map[index++] = new Info("writeCharComponents", 0xa350L);
        map[index++] = new Info("writeShortComponents", 0xa590L);
        map[index++] = new Info("writeIntComponents", 0xa7d0L);
        map[index++] = new Info("writeLongComponents", 0xaa00L);
        map[index++] = new Info("writeFloatComponents", 0xabb0L);
        map[index++] = new Info("writeDoubleComponents", 0xae00L);
        map[index++] = new Info("writeObjectComponents", 0xafc0L);
        map[index++] = new Info("getValues", 0xb160L);
        map[index++] = new Info("readBooleanComponents", 0xb620L);
        map[index++] = new Info("readByteComponents", 0xb730L);
        map[index++] = new Info("readCharComponents", 0xb840L);
        map[index++] = new Info("readShortComponents", 0xb960L);
        map[index++] = new Info("readIntComponents", 0xba80L);
        map[index++] = new Info("readLongComponents", 0xbb90L);
        map[index++] = new Info("readFloatComponents", 0xbcb0L);
        map[index++] = new Info("readDoubleComponents", 0xbdd0L);
        map[index++] = new Info("readObjectComponents", 0xbef0L);
        map[index++] = new Info("setValues", 0xc020L);
        map[index++] = new Info("getComponentClass", 0xc590L);
        map[index++] = new Info("writeNewObjectArray", 0xc6e0L);
        map[index++] = new Info("writeNewPrimitiveArray", 0xc8e0L);
        map[index++] = new Info("newInstance", 0xce30L);
        map[index++] = new Info("superclass", 0xcf30L);
        map[index++] = new Info("readStaticFieldValue", 0xd040L);
        map[index++] = new Info("setValues", 0xd5a0L);
        map[index++] = new Info("invokeStatic", 0xd700L);
        map[index++] = new Info("visibleClasses", 0xd710L);
        map[index++] = new Info("reflectedType", 0xd860L);
        map[index++] = new Info("readAndSetFilters", 0xd8d0L);
        map[index++] = new Info("setCommand", 0xdde0L);
        map[index++] = new Info("clearCommand", 0xdf50L);
        map[index++] = new Info("clearAllBreakpoints", 0xdfe0L);
        map[index++] = new Info("createFrameID", 0xe020L);
        map[index++] = new Info("getFrameNumber", 0xe050L);
        map[index++] = new Info("validateFrameID", 0xe060L);
        map[index++] = new Info("lineTable", 0xe090L);
        map[index++] = new Info("doVariableTable", 0xe280L);
        map[index++] = new Info("variableTable", 0xe580L);
        map[index++] = new Info("variableTableWithGenerics", 0xe590L);
        map[index++] = new Info("bytecodes", 0xe5a0L);
        map[index++] = new Info("isObsolete", 0xe6c0L);
        map[index++] = new Info("referenceType", 0xe740L);
        map[index++] = new Info("getValues", 0xe860L);
        map[index++] = new Info("readFieldValue", 0xe880L);
        map[index++] = new Info("setValues", 0xede0L);
        map[index++] = new Info("monitorInfo", 0xefe0L);
        map[index++] = new Info("invokeInstance", 0xf1a0L);
        map[index++] = new Info("disableCollection", 0xf1b0L);
        map[index++] = new Info("enableCollection", 0xf210L);
        map[index++] = new Info("isCollected", 0xf270L);
        map[index++] = new Info("referringObjects", 0xf300L);
        map[index++] = new Info("signature", 0xf4a0L);
        map[index++] = new Info("signatureWithGeneric", 0xf530L);
        map[index++] = new Info("getClassLoader", 0xf5e0L);
        map[index++] = new Info("modifiers", 0xf660L);
        map[index++] = new Info("writeMethodInfo", 0xf730L);
        map[index++] = new Info("methods1", 0xf860L);
        map[index++] = new Info("methods", 0xf9b0L);
        map[index++] = new Info("methodsWithGeneric", 0xf9c0L);
        map[index++] = new Info("instances", 0xf9d0L);
        map[index++] = new Info("getClassVersion", 0xfb50L);
        map[index++] = new Info("getConstantPool", 0xfc30L);
        map[index++] = new Info("writeFieldInfo", 0xfd40L);
        map[index++] = new Info("fields1", 0xfe70L);
        map[index++] = new Info("fields", 0xffc0L);
        map[index++] = new Info("fieldsWithGeneric", 0xffd0L);
        map[index++] = new Info("getValues", 0xffe0L);
        map[index++] = new Info("sourceFile", 0x10000L);
        map[index++] = new Info("sourceDebugExtension", 0x100d0L);
        map[index++] = new Info("nestedTypes", 0x10150L);
        map[index++] = new Info("getClassStatus", 0x102a0L);
        map[index++] = new Info("interfaces", 0x10300L);
        map[index++] = new Info("classObject", 0x10440L);
        map[index++] = new Info("loadDebugInfo", 0x104a0L);
        map[index++] = new Info("patternMatch", 0x10600L);
        map[index++] = new Info("searchOneSourceName", 0x106a0L);
        map[index++] = new Info("searchAllSourceNames", 0x10730L);
        map[index++] = new Info("convertLineNumberTable", 0x107a0L);
        map[index++] = new Info("setGlobalStratumId", 0x10900L);
        map[index++] = new Info("syntax", 0x10910L);
        map[index++] = new Info("sdePeek", 0x10990L);
        map[index++] = new Info("sdeRead", 0x109d0L);
        map[index++] = new Info("sdeAdvance", 0x10a20L);
        map[index++] = new Info("assureLineTableSize", 0x10a40L);
        map[index++] = new Info("assureFileTableSize", 0x10b30L);
        map[index++] = new Info("assureStratumTableSize", 0x10c20L);
        map[index++] = new Info("readLine", 0x10d10L);
        map[index++] = new Info("defaultStratumTableIndex", 0x10db0L);
        map[index++] = new Info("stratumTableIndex", 0x10df0L);
        map[index++] = new Info("ignoreWhite", 0x10e90L);
        map[index++] = new Info("ignoreLine", 0x10ed0L);
        map[index++] = new Info("readNumber", 0x10f00L);
        map[index++] = new Info("storeFile", 0x10f50L);
        map[index++] = new Info("fileLine", 0x10fc0L);
        map[index++] = new Info("storeLine", 0x11020L);
        map[index++] = new Info("lineLine", 0x110d0L);
        map[index++] = new Info("storeStratum", 0x11190L);
        map[index++] = new Info("stratumSection", 0x11250L);
        map[index++] = new Info("fileSection", 0x11270L);
        map[index++] = new Info("lineSection", 0x112a0L);
        map[index++] = new Info("ignoreSection", 0x112d0L);
        map[index++] = new Info("createJavaStratum", 0x11300L);
        map[index++] = new Info("decode", 0x11380L);
        map[index++] = new Info("stiLineTableIndex", 0x11460L);
        map[index++] = new Info("stiLineNumber", 0x114d0L);
        map[index++] = new Info("isValid", 0x11500L);
        map[index++] = new Info("validateThreadFrame", 0x11520L);
        map[index++] = new Info("writeVariableValue", 0x11570L);
        map[index++] = new Info("readVariableValue", 0x11b80L);
        map[index++] = new Info("getValues", 0x120f0L);
        map[index++] = new Info("setValues", 0x12260L);
        map[index++] = new Info("thisObject", 0x123e0L);
        map[index++] = new Info("popFrames", 0x12640L);
        map[index++] = new Info("value", 0x12710L);
        map[index++] = new Info("name", 0x12880L);
        map[index++] = new Info("parent", 0x12970L);
        map[index++] = new Info("children", 0x12a70L);
        map[index++] = new Info("name", 0x12c50L);
        map[index++] = new Info("suspend", 0x12dd0L);
        map[index++] = new Info("resume", 0x12e60L);
        map[index++] = new Info("status", 0x12ef0L);
        map[index++] = new Info("threadGroup", 0x12f90L);
        map[index++] = new Info("validateSuspendedThread", 0x13110L);
        map[index++] = new Info("frames", 0x13170L);
        map[index++] = new Info("getFrameCount", 0x134f0L);
        map[index++] = new Info("ownedMonitors", 0x135f0L);
        map[index++] = new Info("currentContendedMonitor", 0x137d0L);
        map[index++] = new Info("stop", 0x13960L);
        map[index++] = new Info("interrupt", 0x13a00L);
        map[index++] = new Info("suspendCount", 0x13a90L);
        map[index++] = new Info("ownedMonitorsWithStackDepth", 0x13b20L);
        map[index++] = new Info("forceEarlyReturn", 0x13d30L);
        map[index++] = new Info("version", 0x14330L);
        map[index++] = new Info("classesForSignature", 0x14450L);
        map[index++] = new Info("allClasses1", 0x146f0L);
        map[index++] = new Info("allClasses", 0x14950L);
        map[index++] = new Info("allClassesWithGeneric", 0x14960L);
        map[index++] = new Info("instanceCounts", 0x14970L);
        map[index++] = new Info("redefineClasses", 0x14c50L);
        map[index++] = new Info("setDefaultStratum", 0x14f80L);
        map[index++] = new Info("getAllThreads", 0x14fe0L);
        map[index++] = new Info("topLevelThreadGroups", 0x15110L);
        map[index++] = new Info("dispose", 0x15290L);
        map[index++] = new Info("idSizes", 0x152a0L);
        map[index++] = new Info("suspend", 0x15300L);
        map[index++] = new Info("resume", 0x15360L);
        map[index++] = new Info("doExit", 0x153c0L);
        map[index++] = new Info("createString", 0x15450L);
        map[index++] = new Info("capabilities", 0x15610L);
        map[index++] = new Info("capabilitiesNew", 0x156f0L);
        map[index++] = new Info("countPaths", 0x15920L);
        map[index++] = new Info("writePaths", 0x15980L);
        map[index++] = new Info("classPaths", 0x15a70L);
        map[index++] = new Info("disposeObjects", 0x15b00L);
        map[index++] = new Info("holdEvents", 0x15bb0L);
        map[index++] = new Info("releaseEvents", 0x15bc0L);
        map[index++] = new Info("bagCreateBag", 0x15bd0L);
        map[index++] = new Info("bagDup", 0x15c50L);
        map[index++] = new Info("bagDestroyBag", 0x15ca0L);
        map[index++] = new Info("bagFind", 0x15ce0L);
        map[index++] = new Info("bagAdd", 0x15d20L);
        map[index++] = new Info("bagDelete", 0x15dc0L);
        map[index++] = new Info("bagDeleteAll", 0x15df0L);
        map[index++] = new Info("bagSize", 0x15e00L);
        map[index++] = new Info("bagEnumerateOver", 0x15e10L);
        map[index++] = new Info("hashBucket", 0x15e80L);
        map[index++] = new Info("newSeqNum", 0x15ea0L);
        map[index++] = new Info("createNode", 0x15ed0L);
        map[index++] = new Info("deleteNode", 0x16060L);
        map[index++] = new Info("strengthenNode", 0x161f0L);
        map[index++] = new Info("weakenNode", 0x16380L);
        map[index++] = new Info("findNodeByRef", 0x16480L);
        map[index++] = new Info("deleteNodeByID", 0x16520L);
        map[index++] = new Info("findNodeByID", 0x166a0L);
        map[index++] = new Info("initializeObjectsByID", 0x166f0L);
        map[index++] = new Info("hashIn", 0x16760L);
        map[index++] = new Info("newCommonRef", 0x167b0L);
        map[index++] = new Info("commonRef_initialize", 0x16890L);
        map[index++] = new Info("commonRef_reset", 0x168d0L);
        map[index++] = new Info("commonRef_refToID", 0x169c0L);
        map[index++] = new Info("commonRef_idToRef", 0x16a50L);
        map[index++] = new Info("commonRef_idToRef_delete", 0x16bb0L);
        map[index++] = new Info("commonRef_pin", 0x16bd0L);
        map[index++] = new Info("commonRef_unpin", 0x16c60L);
        map[index++] = new Info("commonRef_release", 0x16cd0L);
        map[index++] = new Info("commonRef_releaseMultiple", 0x16d30L);
        map[index++] = new Info("commonRef_compact", 0x16d80L);
        map[index++] = new Info("commonRef_lock", 0x16ea0L);
        map[index++] = new Info("commonRef_unlock", 0x16ec0L);
        map[index++] = new Info("hashKlass", 0x16ee0L);
        map[index++] = new Info("transferClass", 0x16f10L);
        map[index++] = new Info("deleteTable", 0x16fa0L);
        map[index++] = new Info("classTrack_processUnloads", 0x171e0L);
        map[index++] = new Info("classTrack_addPreparedClass", 0x173e0L);
        map[index++] = new Info("classTrack_initialize", 0x17690L);
        map[index++] = new Info("classTrack_reset", 0x17890L);
        map[index++] = new Info("debugDispatch_initialize", 0x178a0L);
        map[index++] = new Info("debugDispatch_reset", 0x17a30L);
        map[index++] = new Info("debugDispatch_getHandler", 0x17a40L);
        map[index++] = new Info("get_gdata", 0x17a80L);
        map[index++] = new Info("set_event_notification", 0x17ab0L);
        map[index++] = new Info("compatible_versions", 0x17bc0L);
        onLoadIndex = index;
        map[index++] = new Info("Agent_OnLoad", 0x17bf0L);
        map[index++] = new Info("Agent_OnUnload", 0x186b0L);
        map[index++] = new Info("cbEarlyVMInit", 0x186e0L);
        map[index++] = new Info("disposeEnvironment", 0x18820L);
        map[index++] = new Info("cbEarlyVMDeath", 0x18910L);
        map[index++] = new Info("cbEarlyException", 0x18a50L);
        map[index++] = new Info("startTransport", 0x18f00L);
        map[index++] = new Info("signalInitComplete", 0x19040L);
        map[index++] = new Info("debugInit_isInitComplete", 0x190c0L);
        map[index++] = new Info("debugInit_waitInitComplete", 0x190e0L);
        map[index++] = new Info("forceExit", 0x19130L);
        map[index++] = new Info("jniFatalError", 0x19150L);
        map[index++] = new Info("initialize", 0x19290L);
        map[index++] = new Info("debugInit_reset", 0x19920L);
        map[index++] = new Info("debugInit_launchOnInit", 0x19a50L);
        map[index++] = new Info("debugInit_suspendOnInit", 0x19a60L);
        map[index++] = new Info("get_tok", 0x19a80L);
        map[index++] = new Info("printUsage", 0x19af0L);
        map[index++] = new Info("checkAddress", 0x19b10L);
        map[index++] = new Info("add_to_options", 0x19b90L);
        map[index++] = new Info("get_boolean", 0x19c10L);
        map[index++] = new Info("atexit_finish_logging", 0x19c90L);
        map[index++] = new Info("parseOptions", 0x19ca0L);
        map[index++] = new Info("debugInit_exit", 0x1aa80L);
        map[index++] = new Info("lastCommand", 0x1ab60L);
        map[index++] = new Info("resumeCommand", 0x1ab90L);
        map[index++] = new Info("debugLoop_initialize", 0x1abb0L);
        map[index++] = new Info("debugLoop_sync", 0x1abd0L);
        map[index++] = new Info("debugLoop_run", 0x1ac00L);
        map[index++] = new Info("reader", 0x1aed0L);
        map[index++] = new Info("enqueue", 0x1b000L);
        map[index++] = new Info("dequeue", 0x1b110L);
        map[index++] = new Info("notifyTransportError", 0x1b1d0L);
        map[index++] = new Info("vprint_message", 0x1b210L);
        map[index++] = new Info("print_message", 0x1b2c0L);
        map[index++] = new Info("error_message", 0x1b350L);
        map[index++] = new Info("tty_message", 0x1b490L);
        map[index++] = new Info("jdiAssertionFailed", 0x1b560L);
        map[index++] = new Info("jvmtiErrorText", 0x1b690L);
        map[index++] = new Info("eventText", 0x1be90L);
        map[index++] = new Info("jdwpErrorText", 0x1c000L);
        map[index++] = new Info("do_pause", 0x1c6e0L);
        map[index++] = new Info("eventFilterRestricted_alloc", 0x1c770L);
        map[index++] = new Info("clearFilters", 0x1c810L);
        map[index++] = new Info("patternStringMatch", 0x1c9c0L);
        map[index++] = new Info("eventInstance", 0x1ca60L);
        map[index++] = new Info("eventFilterRestricted_passesFilter", 0x1cbe0L);
        map[index++] = new Info("eventFilterRestricted_passesUnloadFilter", 0x1d1f0L);
        map[index++] = new Info("eventFilter_predictFiltering", 0x1d3a0L);
        map[index++] = new Info("eventFilterRestricted_isBreakpointInClass", 0x1d510L);
        map[index++] = new Info("eventFilter_setConditionalFilter", 0x1d550L);
        map[index++] = new Info("eventFilter_setCountFilter", 0x1d580L);
        map[index++] = new Info("eventFilter_setThreadOnlyFilter", 0x1d5c0L);
        map[index++] = new Info("eventFilter_setLocationOnlyFilter", 0x1d620L);
        map[index++] = new Info("eventFilter_setFieldOnlyFilter", 0x1d6c0L);
        map[index++] = new Info("eventFilter_setClassOnlyFilter", 0x1d740L);
        map[index++] = new Info("eventFilter_setExceptionOnlyFilter", 0x1d7b0L);
        map[index++] = new Info("eventFilter_setInstanceOnlyFilter", 0x1d840L);
        map[index++] = new Info("eventFilter_setClassMatchFilter", 0x1d8a0L);
        map[index++] = new Info("eventFilter_setClassExcludeFilter", 0x1d8e0L);
        map[index++] = new Info("eventFilter_setStepFilter", 0x1d920L);
        map[index++] = new Info("eventFilter_setSourceNameMatchFilter", 0x1d9e0L);
        map[index++] = new Info("findFilter", 0x1da20L);
        map[index++] = new Info("matchBreakpoint", 0x1da60L);
        map[index++] = new Info("setBreakpoint", 0x1daf0L);
        map[index++] = new Info("clearBreakpoint", 0x1dbf0L);
        map[index++] = new Info("isBreakpointSet", 0x1dcf0L);
        map[index++] = new Info("matchWatchpoint", 0x1dd20L);
        map[index++] = new Info("setWatchpoint", 0x1dda0L);
        map[index++] = new Info("clearWatchpoint", 0x1ded0L);
        map[index++] = new Info("requestThread", 0x1e000L);
        map[index++] = new Info("matchThread", 0x1e040L);
        map[index++] = new Info("enableEvents", 0x1e070L);
        map[index++] = new Info("disableEvents", 0x1e1b0L);
        map[index++] = new Info("eventFilterRestricted_install", 0x1e2f0L);
        map[index++] = new Info("eventFilterRestricted_deinstall", 0x1e300L);
        map[index++] = new Info("getHandlerChain", 0x1e330L);
        map[index++] = new Info("insert", 0x1e3d0L);
        map[index++] = new Info("findInChain", 0x1e400L);
        map[index++] = new Info("find", 0x1e430L);
        map[index++] = new Info("deinsert", 0x1e450L);
        map[index++] = new Info("eventHandlerRestricted_iterator", 0x1e4a0L);
        map[index++] = new Info("deferEventReport", 0x1e580L);
        map[index++] = new Info("skipEventReport", 0x1e660L);
        map[index++] = new Info("reportEvents", 0x1e720L);
        map[index++] = new Info("synthesizeUnloadEvent", 0x1e890L);
        map[index++] = new Info("event_callback", 0x1ea10L);
        map[index++] = new Info("getObjectClass", 0x1ee80L);
        map[index++] = new Info("getMethodClass", 0x1eef0L);
        map[index++] = new Info("cbSingleStep", 0x1ef90L);
        map[index++] = new Info("cbBreakpoint", 0x1f1c0L);
        map[index++] = new Info("cbFramePop", 0x1f3f0L);
        map[index++] = new Info("cbException", 0x1f620L);
        map[index++] = new Info("cbThreadStart", 0x1f890L);
        map[index++] = new Info("cbThreadEnd", 0x1fa90L);
        map[index++] = new Info("cbClassPrepare", 0x1fc90L);
        map[index++] = new Info("cbGarbageCollectionFinish", 0x1fe90L);
        map[index++] = new Info("cbClassLoad", 0x1ff30L);
        map[index++] = new Info("cbFieldAccess", 0x20130L);
        map[index++] = new Info("cbFieldModification", 0x20390L);
        map[index++] = new Info("cbExceptionCatch", 0x20600L);
        map[index++] = new Info("cbMethodEntry", 0x20850L);
        map[index++] = new Info("cbMethodExit", 0x20a70L);
        map[index++] = new Info("cbMonitorContendedEnter", 0x20cb0L);
        map[index++] = new Info("cbMonitorContendedEntered", 0x20f60L);
        map[index++] = new Info("cbMonitorWait", 0x21210L);
        map[index++] = new Info("cbMonitorWaited", 0x214c0L);
        map[index++] = new Info("cbVMInit", 0x21780L);
        map[index++] = new Info("cbVMDeath", 0x21970L);
        map[index++] = new Info("freeHandler", 0x21b90L);
        map[index++] = new Info("freeHandlerChain", 0x21bd0L);
        map[index++] = new Info("eventHandler_free", 0x21c00L);
        map[index++] = new Info("eventHandler_freeAll", 0x21c40L);
        map[index++] = new Info("eventHandler_freeClassBreakpoints", 0x21cb0L);
        map[index++] = new Info("eventHandler_freeByID", 0x21d30L);
        map[index++] = new Info("eventHandler_initialize", 0x21d90L);
        map[index++] = new Info("eventHandler_reset", 0x223f0L);
        map[index++] = new Info("eventHandler_lock", 0x224a0L);
        map[index++] = new Info("eventHandler_unlock", 0x224c0L);
        map[index++] = new Info("eventHandler_alloc", 0x224e0L);
        map[index++] = new Info("eventHandler_allocHandlerID", 0x22510L);
        map[index++] = new Info("installHandler", 0x22550L);
        map[index++] = new Info("createInternal", 0x225e0L);
        map[index++] = new Info("eventHandler_createPermanentInternal", 0x226b0L);
        map[index++] = new Info("eventHandler_createInternalThreadOnly", 0x226d0L);
        map[index++] = new Info("eventHandler_createInternalBreakpoint", 0x226f0L);
        map[index++] = new Info("eventHandler_installExternal", 0x22730L);
        map[index++] = new Info("commandSize", 0x22760L);
        map[index++] = new Info("freeCommand", 0x22780L);
        map[index++] = new Info("enqueueCommand", 0x227a0L);
        map[index++] = new Info("completeCommand", 0x22900L);
        map[index++] = new Info("dequeueCommand", 0x22960L);
        map[index++] = new Info("eventHelper_holdEvents", 0x22ad0L);
        map[index++] = new Info("eventHelper_releaseEvents", 0x22b10L);
        map[index++] = new Info("writeSingleStepEvent", 0x22b50L);
        map[index++] = new Info("writeBreakpointEvent", 0x22b90L);
        map[index++] = new Info("writeFieldAccessEvent", 0x22bd0L);
        map[index++] = new Info("writeFieldModificationEvent", 0x22c60L);
        map[index++] = new Info("writeExceptionEvent", 0x22d10L);
        map[index++] = new Info("writeThreadEvent", 0x22d90L);
        map[index++] = new Info("writeMonitorEvent", 0x22da0L);
        map[index++] = new Info("writeClassEvent", 0x22ed0L);
        map[index++] = new Info("writeVMDeathEvent", 0x22ff0L);
        map[index++] = new Info("handleEventCommandSingle", 0x23000L);
        map[index++] = new Info("handleUnloadCommandSingle", 0x23230L);
        map[index++] = new Info("handleFrameEventCommandSingle", 0x23280L);
        map[index++] = new Info("suspendWithInvokeEnabled", 0x23350L);
        map[index++] = new Info("handleReportEventCompositeCommand", 0x23380L);
        map[index++] = new Info("handleReportInvokeDoneCommand", 0x234e0L);
        map[index++] = new Info("handleReportVMInitCommand", 0x23510L);
        map[index++] = new Info("handleSuspendThreadCommand", 0x235d0L);
        map[index++] = new Info("handleCommand", 0x23600L);
        map[index++] = new Info("doBlockCommandLoop", 0x236d0L);
        map[index++] = new Info("needBlockCommandLoop", 0x23720L);
        map[index++] = new Info("unblockCommandLoop", 0x23770L);
        map[index++] = new Info("commandLoop", 0x237b0L);
        map[index++] = new Info("eventHelper_initialize", 0x23850L);
        map[index++] = new Info("eventHelper_reset", 0x238e0L);
        map[index++] = new Info("eventHelper_lock", 0x23930L);
        map[index++] = new Info("eventHelper_unlock", 0x23960L);
        map[index++] = new Info("saveEventInfoRefs", 0x23990L);
        map[index++] = new Info("tossEventInfoRefs", 0x23bb0L);
        map[index++] = new Info("eventHelper_createEventBag", 0x23cb0L);
        map[index++] = new Info("enumForCombinedSuspendPolicy", 0x23cd0L);
        map[index++] = new Info("enumForVMDeath", 0x23d20L);
        map[index++] = new Info("enumForCopyingSingles", 0x23d40L);
        map[index++] = new Info("eventHelper_reportEvents", 0x23d80L);
        map[index++] = new Info("eventHelper_recordEvent", 0x23e80L);
        map[index++] = new Info("eventHelper_recordClassUnload", 0x23f70L);
        map[index++] = new Info("eventHelper_recordFrameEvent", 0x24020L);
        map[index++] = new Info("eventHelper_reportInvokeDone", 0x241c0L);
        map[index++] = new Info("eventHelper_reportVMInit", 0x242b0L);
        map[index++] = new Info("eventHelper_suspendThread", 0x243a0L);
        map[index++] = new Info("inStream_init", 0x24490L);
        map[index++] = new Info("inStream_id", 0x24500L);
        map[index++] = new Info("inStream_command", 0x24510L);
        map[index++] = new Info("readBytes", 0x24520L);
        map[index++] = new Info("inStream_skipBytes", 0x24580L);
        map[index++] = new Info("inStream_readBoolean", 0x24590L);
        map[index++] = new Info("inStream_readByte", 0x245e0L);
        map[index++] = new Info("inStream_readBytes", 0x24600L);
        map[index++] = new Info("inStream_readChar", 0x24630L);
        map[index++] = new Info("inStream_readShort", 0x24660L);
        map[index++] = new Info("inStream_readInt", 0x246a0L);
        map[index++] = new Info("inStream_readLong", 0x246f0L);
        map[index++] = new Info("inStream_readFloat", 0x247b0L);
        map[index++] = new Info("inStream_readDouble", 0x247e0L);
        map[index++] = new Info("inStream_readObjectRef", 0x24810L);
        map[index++] = new Info("inStream_readObjectID", 0x248a0L);
        map[index++] = new Info("inStream_readClassRef", 0x248b0L);
        map[index++] = new Info("inStream_readThreadRef", 0x248f0L);
        map[index++] = new Info("inStream_readThreadGroupRef", 0x24930L);
        map[index++] = new Info("inStream_readStringRef", 0x24970L);
        map[index++] = new Info("inStream_readClassLoaderRef", 0x249b0L);
        map[index++] = new Info("inStream_readArrayRef", 0x249f0L);
        map[index++] = new Info("inStream_readFrameID", 0x24a30L);
        map[index++] = new Info("inStream_readMethodID", 0x24a40L);
        map[index++] = new Info("inStream_readFieldID", 0x24a50L);
        map[index++] = new Info("inStream_readLocation", 0x24a60L);
        map[index++] = new Info("inStream_readString", 0x24a70L);
        map[index++] = new Info("inStream_endOfInput", 0x24b30L);
        map[index++] = new Info("inStream_error", 0x24b40L);
        map[index++] = new Info("inStream_clearError", 0x24b50L);
        map[index++] = new Info("inStream_readValue", 0x24b60L);
        map[index++] = new Info("deleteRef", 0x24d40L);
        map[index++] = new Info("inStream_destroy", 0x24d60L);
        map[index++] = new Info("invoker_initialize", 0x24db0L);
        map[index++] = new Info("invoker_reset", 0x24dd0L);
        map[index++] = new Info("invoker_lock", 0x24de0L);
        map[index++] = new Info("invoker_unlock", 0x24e00L);
        map[index++] = new Info("returnTypeTag", 0x24e20L);
        map[index++] = new Info("nextArgumentTypeTag", 0x24e80L);
        map[index++] = new Info("firstArgumentTypeTag", 0x24f20L);
        map[index++] = new Info("createGlobalRefs", 0x24f80L);
        map[index++] = new Info("fillInvokeRequest", 0x251c0L);
        map[index++] = new Info("invoker_enableInvokeRequests", 0x25290L);
        map[index++] = new Info("invoker_requestInvoke", 0x25360L);
        map[index++] = new Info("invokeConstructor", 0x25420L);
        map[index++] = new Info("invokeStatic", 0x254c0L);
        map[index++] = new Info("invokeVirtual", 0x25aa0L);
        map[index++] = new Info("invokeNonvirtual", 0x26080L);
        map[index++] = new Info("invoker_doInvoke", 0x26690L);
        map[index++] = new Info("invoker_completeInvokeRequest", 0x269c0L);
        map[index++] = new Info("invoker_isPending", 0x26c50L);
        map[index++] = new Info("invoker_isEnabled", 0x26d20L);
        map[index++] = new Info("invoker_detach", 0x26df0L);
        map[index++] = new Info("get_time_stamp", 0x26e60L);
        map[index++] = new Info("file_basename", 0x26f20L);
        map[index++] = new Info("fill_location_stamp", 0x26f80L);
        map[index++] = new Info("log_message_begin", 0x26fe0L);
        map[index++] = new Info("standard_logging_format", 0x27040L);
        map[index++] = new Info("log_message_end", 0x270a0L);
        map[index++] = new Info("setup_logging", 0x27290L);
        map[index++] = new Info("finish_logging", 0x27320L);
        map[index++] = new Info("commonInit", 0x27380L);
        map[index++] = new Info("outStream_initCommand", 0x27400L);
        map[index++] = new Info("outStream_initReply", 0x27450L);
        map[index++] = new Info("outStream_id", 0x27480L);
        map[index++] = new Info("outStream_command", 0x27490L);
        map[index++] = new Info("writeBytes", 0x274f0L);
        map[index++] = new Info("outStream_writeBoolean", 0x27610L);
        map[index++] = new Info("outStream_writeByte", 0x27640L);
        map[index++] = new Info("outStream_writeChar", 0x27660L);
        map[index++] = new Info("outStream_writeShort", 0x276a0L);
        map[index++] = new Info("outStream_writeInt", 0x276e0L);
        map[index++] = new Info("outStream_writeLong", 0x27730L);
        map[index++] = new Info("outStream_writeFloat", 0x277f0L);
        map[index++] = new Info("outStream_writeDouble", 0x27840L);
        map[index++] = new Info("outStream_writeObjectTag", 0x27890L);
        map[index++] = new Info("outStream_writeObjectRef", 0x278c0L);
        map[index++] = new Info("outStream_writeFrameID", 0x27a10L);
        map[index++] = new Info("outStream_writeMethodID", 0x27a20L);
        map[index++] = new Info("outStream_writeFieldID", 0x27a30L);
        map[index++] = new Info("outStream_writeLocation", 0x27a40L);
        map[index++] = new Info("outStream_writeByteArray", 0x27a50L);
        map[index++] = new Info("outStream_writeString", 0x27a90L);
        map[index++] = new Info("outStream_writeValue", 0x27b90L);
        map[index++] = new Info("outStream_skipBytes", 0x27e20L);
        map[index++] = new Info("outStream_error", 0x27eb0L);
        map[index++] = new Info("outStream_setError", 0x27ec0L);
        map[index++] = new Info("outStream_send", 0x27f30L);
        map[index++] = new Info("outStream_sendReply", 0x28000L);
        map[index++] = new Info("outStream_sendCommand", 0x28050L);
        map[index++] = new Info("releaseID", 0x28080L);
        map[index++] = new Info("outStream_destroy", 0x280b0L);
        map[index++] = new Info("handleClassPrepare", 0x28130L);
        map[index++] = new Info("handleGarbageCollectionFinish", 0x28190L);
        map[index++] = new Info("handleFrameEvent", 0x281d0L);
        map[index++] = new Info("genericHandler", 0x282a0L);
        map[index++] = new Info("standardHandlers_defaultHandler", 0x282c0L);
        map[index++] = new Info("standardHandlers_onConnect", 0x283b0L);
        map[index++] = new Info("standardHandlers_onDisconnect", 0x28450L);
        map[index++] = new Info("getFrameCount", 0x28460L);
        map[index++] = new Info("enableStepping", 0x28550L);
        map[index++] = new Info("disableStepping", 0x28620L);
        map[index++] = new Info("getFrameLocation", 0x286f0L);
        map[index++] = new Info("getLineNumberTable", 0x287b0L);
        map[index++] = new Info("findLineNumber", 0x28870L);
        map[index++] = new Info("hasLineNumbers", 0x288c0L);
        map[index++] = new Info("initState", 0x288f0L);
        map[index++] = new Info("handleFramePopEvent", 0x28b40L);
        map[index++] = new Info("handleExceptionCatchEvent", 0x28da0L);
        map[index++] = new Info("handleMethodEnterEvent", 0x28f00L);
        map[index++] = new Info("completeStep", 0x290a0L);
        map[index++] = new Info("stepControl_handleStep", 0x29190L);
        map[index++] = new Info("stepControl_initialize", 0x29860L);
        map[index++] = new Info("stepControl_reset", 0x29880L);
        map[index++] = new Info("stepControl_resetRequest", 0x29890L);
        map[index++] = new Info("initEvents", 0x29a00L);
        map[index++] = new Info("stepControl_beginStep", 0x29b80L);
        map[index++] = new Info("clearStep", 0x29d00L);
        map[index++] = new Info("stepControl_endStep", 0x29d60L);
        map[index++] = new Info("stepControl_clearRequest", 0x29df0L);
        map[index++] = new Info("stepControl_lock", 0x29e50L);
        map[index++] = new Info("stepControl_unlock", 0x29e70L);
        map[index++] = new Info("stream_encodeFloat", 0x29e90L);
        map[index++] = new Info("stream_encodeDouble", 0x29ed0L);
        map[index++] = new Info("getStackDepth", 0x29f80L);
        map[index++] = new Info("threadState", 0x2a070L);
        map[index++] = new Info("setThreadLocalStorage", 0x2a100L);
        map[index++] = new Info("getThreadLocalStorage", 0x2a1f0L);
        map[index++] = new Info("nonTlsSearch", 0x2a2f0L);
        map[index++] = new Info("findThread", 0x2a340L);
        map[index++] = new Info("removeNode", 0x2a3f0L);
        map[index++] = new Info("addNode", 0x2a440L);
        map[index++] = new Info("insertThread", 0x2a490L);
        map[index++] = new Info("clearThread", 0x2a6f0L);
        map[index++] = new Info("removeThread", 0x2a770L);
        map[index++] = new Info("removeResumed", 0x2a7d0L);
        map[index++] = new Info("moveNode", 0x2a820L);
        map[index++] = new Info("enumerateOverThreadList", 0x2a890L);
        map[index++] = new Info("insertEventMode", 0x2a8e0L);
        map[index++] = new Info("removeEventMode", 0x2a900L);
        map[index++] = new Info("addDeferredEventMode", 0x2a930L);
        map[index++] = new Info("freeDeferredEventModes", 0x2a9b0L);
        map[index++] = new Info("threadSetEventNotificationMode", 0x2aa10L);
        map[index++] = new Info("processDeferredEventModes", 0x2aab0L);
        map[index++] = new Info("getLocks", 0x2abf0L);
        map[index++] = new Info("releaseLocks", 0x2ac20L);
        map[index++] = new Info("threadControl_initialize", 0x2ac50L);
        map[index++] = new Info("getResumee", 0x2ae30L);
        map[index++] = new Info("pendingAppResume", 0x2aed0L);
        map[index++] = new Info("notifyAppResumeComplete", 0x2afe0L);
        map[index++] = new Info("handleAppResumeCompletion", 0x2b040L);
        map[index++] = new Info("blockOnDebuggerSuspend", 0x2b0c0L);
        map[index++] = new Info("trackAppResume", 0x2b120L);
        map[index++] = new Info("handleAppResumeBreakpoint", 0x2b2a0L);
        map[index++] = new Info("threadControl_onConnect", 0x2b300L);
        map[index++] = new Info("threadControl_onDisconnect", 0x2b340L);
        map[index++] = new Info("threadControl_onHook", 0x2b3a0L);
        map[index++] = new Info("commonSuspendByNode", 0x2b510L);
        map[index++] = new Info("deferredSuspendThreadByNode", 0x2b5e0L);
        map[index++] = new Info("suspendThreadByNode", 0x2b640L);
        map[index++] = new Info("resumeThreadByNode", 0x2b6c0L);
        map[index++] = new Info("preSuspend", 0x2b810L);
        map[index++] = new Info("postSuspend", 0x2b870L);
        map[index++] = new Info("commonSuspend", 0x2b880L);
        map[index++] = new Info("resumeCopyHelper", 0x2b8f0L);
        map[index++] = new Info("resumeCountHelper", 0x2b960L);
        map[index++] = new Info("newArray", 0x2b990L);
        map[index++] = new Info("deleteArray", 0x2b9e0L);
        map[index++] = new Info("commonResumeList", 0x2b9f0L);
        map[index++] = new Info("commonSuspendList", 0x2bd70L);
        map[index++] = new Info("commonResume", 0x2c830L);
        map[index++] = new Info("threadControl_suspendThread", 0x2c850L);
        map[index++] = new Info("threadControl_resumeThread", 0x2c8b0L);
        map[index++] = new Info("threadControl_suspendCount", 0x2c930L);
        map[index++] = new Info("contains", 0x2c9b0L);
        map[index++] = new Info("suspendAllHelper", 0x2ca20L);
        map[index++] = new Info("threadControl_suspendAll", 0x2ca70L);
        map[index++] = new Info("resumeHelper", 0x2cbd0L);
        map[index++] = new Info("threadControl_resumeAll", 0x2cbe0L);
        map[index++] = new Info("threadControl_getStepRequest", 0x2ccc0L);
        map[index++] = new Info("threadControl_getInvokeRequest", 0x2cd20L);
        map[index++] = new Info("threadControl_addDebugThread", 0x2cd80L);
        map[index++] = new Info("threadControl_removeDebugThread", 0x2ce20L);
        map[index++] = new Info("threadControl_isDebugThread", 0x2cf80L);
        map[index++] = new Info("initLocks", 0x2d020L);
        map[index++] = new Info("getPopFrameThread", 0x2d070L);
        map[index++] = new Info("setPopFrameThread", 0x2d0d0L);
        map[index++] = new Info("getPopFrameEvent", 0x2d1a0L);
        map[index++] = new Info("setPopFrameEvent", 0x2d270L);
        map[index++] = new Info("getPopFrameProceed", 0x2d350L);
        map[index++] = new Info("setPopFrameProceed", 0x2d420L);
        map[index++] = new Info("popFrameCompleteEvent", 0x2d4f0L);
        map[index++] = new Info("popOneFrame", 0x2d590L);
        map[index++] = new Info("threadControl_popFrames", 0x2d7a0L);
        map[index++] = new Info("checkForPopFrameEvents", 0x2d8c0L);
        map[index++] = new Info("threadControl_onEventHandlerEntry", 0x2da10L);
        map[index++] = new Info("doPendingTasks", 0x2dbe0L);
        map[index++] = new Info("threadControl_onEventHandlerExit", 0x2dcf0L);
        map[index++] = new Info("threadControl_applicationThreadStatus", 0x2de40L);
        map[index++] = new Info("threadControl_interrupt", 0x2def0L);
        map[index++] = new Info("threadControl_clearCLEInfo", 0x2dfc0L);
        map[index++] = new Info("threadControl_cmpCLEInfo", 0x2e030L);
        map[index++] = new Info("threadControl_saveCLEInfo", 0x2e0d0L);
        map[index++] = new Info("threadControl_setPendingInterrupt", 0x2e160L);
        map[index++] = new Info("threadControl_stop", 0x2e1b0L);
        map[index++] = new Info("detachHelper", 0x2e2a0L);
        map[index++] = new Info("threadControl_detachInvokes", 0x2e2c0L);
        map[index++] = new Info("resetHelper", 0x2e320L);
        map[index++] = new Info("threadControl_reset", 0x2e410L);
        map[index++] = new Info("threadControl_getInstructionStepMode", 0x2e4e0L);
        map[index++] = new Info("threadControl_setEventMode", 0x2e530L);
        map[index++] = new Info("threadControl_currentThread", 0x2e630L);
        map[index++] = new Info("threadControl_getFrameGeneration", 0x2e680L);
        map[index++] = new Info("printLastError", 0x2e6e0L);
        map[index++] = new Info("findTransportOnLoad", 0x2e8c0L);
        map[index++] = new Info("loadTransportLibrary", 0x2e8e0L);
        map[index++] = new Info("loadTransport", 0x2e980L);
        map[index++] = new Info("connectionInitiated", 0x2ed30L);
        map[index++] = new Info("setTransportProperty", 0x2edf0L);
        map[index++] = new Info("transport_waitForConnection", 0x2ee20L);
        map[index++] = new Info("acceptThread", 0x2ee80L);
        map[index++] = new Info("attachThread", 0x2efd0L);
        map[index++] = new Info("transport_initialize", 0x2f070L);
        map[index++] = new Info("transport_reset", 0x2f0b0L);
        map[index++] = new Info("launch", 0x2f100L);
        map[index++] = new Info("transport_startTransport", 0x2f210L);
        map[index++] = new Info("transport_close", 0x2f4f0L);
        map[index++] = new Info("transport_is_open", 0x2f510L);
        map[index++] = new Info("transport_sendPacket", 0x2f530L);
        map[index++] = new Info("transport_receivePacket", 0x2f5d0L);
        map[index++] = new Info("saveGlobalRef", 0x2f640L);
        map[index++] = new Info("tossGlobalRef", 0x2f910L);
        map[index++] = new Info("findClass", 0x2faf0L);
        map[index++] = new Info("getMethod", 0x2fe20L);
        map[index++] = new Info("getStaticMethod", 0x30260L);
        map[index++] = new Info("util_initialize", 0x306b0L);
        map[index++] = new Info("util_reset", 0x30db0L);
        map[index++] = new Info("isObjectTag", 0x30dc0L);
        map[index++] = new Info("specificTypeKey", 0x30e00L);
        map[index++] = new Info("writeFieldValue", 0x31110L);
        map[index++] = new Info("writeStaticFieldValue", 0x316a0L);
        map[index++] = new Info("sharedGetFieldValues", 0x31bf0L);
        map[index++] = new Info("sharedInvoke", 0x31d80L);
        map[index++] = new Info("uniqueID", 0x32000L);
        map[index++] = new Info("filterDebugThreads", 0x32020L);
        map[index++] = new Info("referenceTypeTag", 0x32210L);
        map[index++] = new Info("fieldModifiers", 0x32250L);
        map[index++] = new Info("methodModifiers", 0x322e0L);
        map[index++] = new Info("methodClass", 0x32370L);
        map[index++] = new Info("methodLocation", 0x323a0L);
        map[index++] = new Info("methodSignature", 0x32420L);
        map[index++] = new Info("methodReturnType", 0x324e0L);
        map[index++] = new Info("classLoader", 0x32550L);
        map[index++] = new Info("fieldSignature", 0x325e0L);
        map[index++] = new Info("getEnv", 0x326f0L);
        map[index++] = new Info("spawnNewThread", 0x327f0L);
        map[index++] = new Info("jvmtiGetCapabilities", 0x32c40L);
        map[index++] = new Info("jvmtiVersion", 0x32d00L);
        map[index++] = new Info("jvmtiMajorVersion", 0x32e00L);
        map[index++] = new Info("jvmtiMinorVersion", 0x32e20L);
        map[index++] = new Info("jvmtiMicroVersion", 0x32e40L);
        map[index++] = new Info("canSuspendResumeThreadLists", 0x32e50L);
        map[index++] = new Info("getSourceDebugExtension", 0x32e80L);
        map[index++] = new Info("convertSignatureToClassname", 0x32f00L);
        map[index++] = new Info("handleInterrupt", 0x32f50L);
        map[index++] = new Info("ignore_vm_death", 0x32f90L);
        map[index++] = new Info("debugMonitorEnter", 0x32fe0L);
        map[index++] = new Info("debugMonitorExit", 0x330c0L);
        map[index++] = new Info("debugMonitorWait", 0x33160L);
        map[index++] = new Info("debugMonitorTimedWait", 0x33210L);
        map[index++] = new Info("debugMonitorNotify", 0x332c0L);
        map[index++] = new Info("debugMonitorNotifyAll", 0x33360L);
        map[index++] = new Info("debugMonitorCreate", 0x33400L);
        map[index++] = new Info("debugMonitorDestroy", 0x334b0L);
        map[index++] = new Info("allThreads", 0x33550L);
        map[index++] = new Info("threadGroupInfo", 0x33660L);
        map[index++] = new Info("classSignature", 0x33750L);
        map[index++] = new Info("getClassname", 0x337c0L);
        map[index++] = new Info("writeGenericSignature", 0x33810L);
        map[index++] = new Info("classStatus", 0x33830L);
        map[index++] = new Info("isArrayClass", 0x33920L);
        map[index++] = new Info("isInterface", 0x33a10L);
        map[index++] = new Info("isFieldSynthetic", 0x33b00L);
        map[index++] = new Info("isMethodSynthetic", 0x33b90L);
        map[index++] = new Info("isMethodNative", 0x33c20L);
        map[index++] = new Info("isSameObject", 0x33d10L);
        map[index++] = new Info("objectHashCode", 0x33d30L);
        map[index++] = new Info("allInterfaces", 0x33e20L);
        map[index++] = new Info("allLoadedClasses", 0x33eb0L);
        map[index++] = new Info("allClassLoaderClasses", 0x33f40L);
        map[index++] = new Info("is_a_nested_class", 0x33fd0L);
        map[index++] = new Info("allNestedClasses", 0x34080L);
        map[index++] = new Info("createLocalRefSpace", 0x34230L);
        map[index++] = new Info("isClass", 0x34420L);
        map[index++] = new Info("isThread", 0x344b0L);
        map[index++] = new Info("isThreadGroup", 0x34540L);
        map[index++] = new Info("isString", 0x345d0L);
        map[index++] = new Info("isClassLoader", 0x34660L);
        map[index++] = new Info("isArray", 0x346f0L);
        map[index++] = new Info("getPropertyValue", 0x347e0L);
        map[index++] = new Info("setAgentPropertyValue", 0x34a10L);
        map[index++] = new Info("getPropertyUTF8", 0x34c10L);
        map[index++] = new Info("isMethodObsolete", 0x34e50L);
        map[index++] = new Info("getSpecialJvmti", 0x34ee0L);
        map[index++] = new Info("writeCodeLocation", 0x34fe0L);
        map[index++] = new Info("jvmtiAllocate", 0x35060L);
        map[index++] = new Info("jvmtiDeallocate", 0x35110L);
        map[index++] = new Info("map2jvmtiError", 0x351b0L);
        map[index++] = new Info("eventIndexInit", 0x35810L);
        map[index++] = new Info("eventIndex2jdwp", 0x35970L);
        map[index++] = new Info("eventIndex2jvmti", 0x35a10L);
        map[index++] = new Info("jdwp2EventIndex", 0x35ab0L);
        map[index++] = new Info("jvmti2EventIndex", 0x35d00L);
        map[index++] = new Info("map2jdwpError", 0x35f70L);
        map[index++] = new Info("map2jdwpSuspendStatus", 0x36630L);
        map[index++] = new Info("map2jdwpThreadStatus", 0x36650L);
        map[index++] = new Info("map2jdwpClassStatus", 0x366b0L);
        map[index++] = new Info("log_debugee_location", 0x36700L);
        map[index++] = new Info("cbObjectTagInstance", 0x368e0L);
        map[index++] = new Info("classInstances", 0x36930L);
        map[index++] = new Info("cbObjectCounterFromRef", 0x36b40L);
        map[index++] = new Info("cbObjectCounter", 0x36be0L);
        map[index++] = new Info("classInstanceCounts", 0x36c40L);
        map[index++] = new Info("cbObjectTagReferrer", 0x37010L);
        map[index++] = new Info("objectReferrers", 0x37090L);
        map[index++] = new Info("dbgsysBuildFunName", 0x37370L);
        map[index++] = new Info("dbgsysBuildLibName", 0x37390L);
        map[index++] = new Info("dbgsysLoadLibrary", 0x37430L);
        map[index++] = new Info("dbgsysUnloadLibrary", 0x37490L);
        map[index++] = new Info("dbgsysFindLibraryEntry", 0x374a0L);
        map[index++] = new Info("skipWhitespace", 0x374b0L);
        map[index++] = new Info("skipNonWhitespace", 0x37500L);
        map[index++] = new Info("dbgsysExec", 0x37550L);
    }

    private static final int SYMBOL_COUNT = 713;
    static {
        map = new Info[SYMBOL_COUNT];
        initializeMap();
    }
// END GENERATED CODE

    static void fixup(long onloadAddress) {
        long base = onloadAddress - map[onLoadIndex].value.toLong();
        for (int i = 0; i < map.length; i++) {
            map[i].value = Address.fromLong(map[i].value.toLong() + base);
            if (i > 0) {
                map[i - 1].length = i == map.length - 1 ? 100 : (int) (map[i].value.toLong() - map[i -  1].value.toLong());
            }
        }
    }

    static void dump() {
        try {
            PrintStream fs = new PrintStream(new FileOutputStream("jdwp.addr"));
            for (Info info : map) {
                fs.printf("%s,%s,%d%n", info.name, Long.toHexString(info.value.toLong()), info.length);
            }
            fs.close();
        } catch (IOException ex) {
            FatalError.unexpected("failed write JDWP address file", ex);
        }
    }

    @HOSTED_ONLY
    private static boolean generate() throws Exception {
        File base = new File(JavaProject.findWorkspaceDirectory(), "com.oracle.max.vm/src");
        File outputFile = new File(base, JDWPSymbols.class.getName().replace('.', File.separatorChar) + ".java").getAbsoluteFile();
        // Assume a file called jdwp.objdump.functions
        BufferedReader reader  = null;
        try {
            reader = new BufferedReader(new FileReader(new File(JavaProject.findWorkspaceDirectory(), "jdwp.objdump.functions")));
            Writer writer = new StringWriter();
            PrintWriter out = new PrintWriter(writer);
            int symbolCount = 0;
            boolean onLoadFound = false;
            out.println("    @HOSTED_ONLY");
            out.println("    private static void initializeMap() {");
            while (true) {
                String line = reader.readLine();
                if (line == null) {
                    break;
                }
                if (line.length() == 0 || line.charAt(0) == '#') {
                    continue;
                }
                String[] parts = line.split(" ");
                String name = parts[1].substring(1, parts[1].length() - 2);
                if (!onLoadFound && name.equals("Agent_OnLoad")) {
                    out.println("        onLoadIndex = index;");
                    onLoadFound = true;
                }
                out.printf("        map[index++] = new Info(\"%s\", 0x%sL);%n", name, stripZeroes(parts[0]));
                symbolCount++;
            }
            out.println("    }\n");
            out.printf("    private static final int SYMBOL_COUNT = %d;%n", symbolCount);
            out.println("    static {");
            out.printf("        map = new Info[SYMBOL_COUNT];\n");
            out.println("        initializeMap();");
            out.println("    }");

            return Files.updateGeneratedContent(outputFile, ReadableSource.Static.fromString(writer.toString()), "// START GENERATED CODE", "// END GENERATED CODE", false);
        } finally {
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException ex) {
                }
            }
        }
    }

    @HOSTED_ONLY
    private static String stripZeroes(String s) {
        int index = 0;
        while (index < s.length()) {
            if (s.charAt(index) != '0') {
                break;
            }
            index++;
        }
        assert index < s.length();
        return s.substring(index);
    }

    @HOSTED_ONLY
    public static void main(String[] args) throws Exception {
        boolean updated = false;
        if (generate()) {
            System.out.println("Source for " + JDWPSymbols.class + " was updated");
            System.exit(1);
        }
    }

}
