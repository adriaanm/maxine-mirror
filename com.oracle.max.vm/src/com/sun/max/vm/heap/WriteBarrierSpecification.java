/*
 * Copyright (c) 2011, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.max.vm.heap;

import com.sun.max.util.*;


public interface WriteBarrierSpecification {

    public enum WriteBarrierSpec {
        /**
         * Indicate that the barrier applies to a reference held by a tuple.
         */
        TUPLE_CELL,
        /**
         * Indicate that the barrier applies to a reference held by a array.
         */
        ARRAY_CELL,
        /**
         * Indicates that the barrier must be generated before the store.
         */
        PRE_WRITE,
        /**
         * Indicates that the barrier must be generated after the store.
         */
        POST_WRITE,
        /**
         * Indicates that the barrier is generated at runtime. "Constants" defined at
         * VM startup are available, and the barrier may take advantage of this.
         */
        RUNTIME_GENERATED,
        /**
         * Indicates that the barrier is generated by the image generator. Some runtime-only constants
         * may not be available, which may require an alternate implementation.
         */
        HOST_GENERATED,
        /**
         * The barrier needs the origin of the cell holding the updated reference.
         * This applies both for tuple and array cells.
         */
        NEEDS_ORIGIN,
        /**
         * The barrier needs the precise address of the updated reference location.
         */
        NEEDS_REF_ADDR,
        /**
         * The barrier needs a field offset. Relevant only for barrier generated for tuples.
         */
        NEEDS_FIELD_OFFSET,
        /**
         * The barrier needs an index. Relevant only for barrier generated for arrays.
         */
        NEEDS_ARRAY_INDEX,
        /**
         * The barrier needs the new value of the updated references.
         */
        NEEDS_NEW_VALUE;
    }
    IntBitSet<WriteBarrierSpec> TUPLE_PRE_BARRIER = new IntBitSet<WriteBarrierSpec>().set(WriteBarrierSpec.TUPLE_CELL).set(WriteBarrierSpec.PRE_WRITE);
    IntBitSet<WriteBarrierSpec> TUPLE_POST_BARRIER = new IntBitSet<WriteBarrierSpec>().set(WriteBarrierSpec.TUPLE_CELL).set(WriteBarrierSpec.POST_WRITE);
    IntBitSet<WriteBarrierSpec> ARRAY_PRE_BARRIER = new IntBitSet<WriteBarrierSpec>().set(WriteBarrierSpec.ARRAY_CELL).set(WriteBarrierSpec.PRE_WRITE);
    IntBitSet<WriteBarrierSpec> ARRAY_POST_BARRIER = new IntBitSet<WriteBarrierSpec>().set(WriteBarrierSpec.ARRAY_CELL).set(WriteBarrierSpec.POST_WRITE);

}
