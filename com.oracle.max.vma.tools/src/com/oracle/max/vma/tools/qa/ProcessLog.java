/*
 * Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.oracle.max.vma.tools.qa;

import static com.oracle.max.vm.ext.vma.store.txt.CVMATextStore.*;
import static com.oracle.max.vma.tools.qa.TransientVMAdviceHandlerTypes.*;
import static com.oracle.max.vma.tools.qa.TransientVMAdviceHandlerTypes.RecordType.*;

import java.io.*;
import java.util.*;

import com.oracle.max.vm.ext.vma.*;
import com.oracle.max.vm.ext.vma.store.*;
import com.oracle.max.vm.ext.vma.store.txt.*;
import com.oracle.max.vma.tools.log.*;
import com.sun.max.program.*;

/**
 * Reads a log file in the format generated by {@link CSFVMATextStore}.
 *
 * Object identifiers in the log may be reused owing to garbage collection. Object identifiers in the {@link #objects}
 * map are unique and always qualified by the allocation (gc) epoch, {@link #allocationEpoch). I.e., an id X in the log is
 * stored as "X:allocationEpoch", e.g. "X:0, X:3, ..."
 *
 * Note that although the map may contain many instances of X:n, at any point in time there can only be one active
 * instance, which is the value of "n" given by the {@link #maxAllocationEpoch} map.
 *
 * The log must be time ordered for the main body of the code to work properly.
 * An unordered log is detected automatically and converted using {@link ConvertLog}.
 *
 *
 */
public class ProcessLog {

    static class TraceException extends Exception {

        static final long serialVersionUID = 0;

        TraceException(String s) {
            super(s);
        }
    }

    static class ClassNameId implements Comparable {

        String className;
        String clId;

        ClassNameId(String name, String id) {
            this.className = name;
            this.clId = id;
        }

        public int compareTo(Object other) {
            ClassNameId otherClassName = (ClassNameId) other;
            if (otherClassName.className.equals(className)) {
                return clId.compareTo(otherClassName.clId);
            } else {
                return className.compareTo(otherClassName.className);
            }
        }

        @Override
        public int hashCode() {
            return className.hashCode() ^ clId.hashCode();
        }

        @Override
        public boolean equals(Object other) {
            return compareTo(other) == 0;
        }

        @Override
        public String toString() {
            return className + "(cl:" + clId + ")";
        }
    }

    private boolean verbose = false;
    private int maxLines;

    /**
     * Experimentally determined, used to set the size of the {@link #adviceRecordList}.
     */
    private static final int AVG_LINE_LENGTH = 17;  //

    private Map<String, ObjectRecord> objects = new HashMap<String, ObjectRecord>(1024 * 1024);

    private SortedMap<ClassNameId, ClassRecord> classMap = new TreeMap<ClassNameId, ClassRecord>();
    private Map<String, ThreadRecord> threadMap = new HashMap<String, ThreadRecord>();
    private Map<String, FieldRecord> fieldMap = new HashMap<String, FieldRecord>();
    private Map<String, MethodRecord> methodMap = new HashMap<String, MethodRecord>();

    private ArrayList<AllocationEpoch> allocationEpochs = new ArrayList<AllocationEpoch>();

    private long objectCount = 0;
    private long arrayCount = 0;

    private int missingConstructorCount = 0;

    private long startTime;   // absolute value in trace
    private long lastTime;    // absolute value computed from startTime + increments in the trace records
    private boolean absTime;  // if log uses absolute time

    private AllocationEpoch allocationEpoch;
    private AllocationEpoch prevAllocationEpoch;
    /**
     * Key is an unqualified id and the value is the last allocation epoch that id was defined (allocated) in.
     * I.e., to get a qualified id, look up the value mapped from the unqualified id and append it.
     */
    private Map<String, Integer> maxAllocationEpoch = new HashMap<String, Integer>();
    private int startRemoval = -1;
    private int endRemoval;

    private Map<String, String> lastId = new HashMap<String, String>();

    // Following fields hold the values for the current trace (if appropriate)
    private ObjectRecord objectRecord;
    private FieldRecord fieldRecord;
    private MethodRecord methodRecord;
    private ThreadRecord threadRecord;
    private ClassRecord classRecord;

    private Map<String, ObjectRecord> missingConstructors = new HashMap<String, ObjectRecord>();

    /* These maps hold forward references that can occur in logs that were generated by
     * the per-thread batching generator. Even when time ordered, one thread may use
     * a short form that is defined later in another thread. This is because there is
     * no relationship between the time the thread buffer is flushed and the time the
     * short form is created.
     */

    /*
     *  The key of the next two maps is the short form and the value (when defined) is the actual name.
     */
    private Map<String, ClassNameId> classShortFormsToFull = new HashMap<String, ClassNameId>();
    private Map<String, String> threadShortFormsToFull = new HashMap<String, String>();

    private Map<String, ClassNameId> classForwardsMap = new HashMap<String, ClassNameId>();
    private static final String CLASS_FORWARD_PREFIX = "ClassForward:";

    /*
     * Life is more complicated for fields/methods so we have a generic handler class.
     *
     * Fields and methods are more complicated because they are only unique when qualified
     * with a class, and it is possible that both the field and the class are forward references.
     * So the key of the forward references map is C.X, where C is the class (and may itself be
     * a forward reference) and X is the field or method short name. So there are three possibilities:
     * 1) C and X are not forward references
     * 2) C is a forward reference and X is not
     * 3) X is a forward reference and C is not
     *
     * The case where C is a forward reference is tricky because at the time the field/method
     * is defined, C may or may not have been defined in the interim. If not, there is no problem
     * as calling getClassRecord will get the same C value as when C.X was originally
     * generated. However, if C has been defined in the interim, calling getClassRecord will
     * get the resolved name, which means that the lookup in the field/method forwards map
     * will fail. But we can't blindly use the forward name for the class as it may have been
     * defined initially (cases 1 and 3). The simplest solution for this is to fixup the
     * field/method forward maps when a class definition occurs, so that it is always safe to
     * get C by calling getClassRecord.
     */
    private interface Factory<T> {
        T create(ClassRecord cr, String name);
    }

    private static class FieldRecordFactory implements Factory<FieldRecord> {
        @Override
        public FieldRecord create(ClassRecord cr, String name) {
            return new FieldRecord(cr, name);
        }
    }

    private static class MethodRecordFactory implements Factory<MethodRecord> {
        @Override
        public MethodRecord create(ClassRecord cr, String name) {
            return new MethodRecord(cr, name);
        }
    }

    private class ShortFormHandler<T extends MemberRecord> {
        /*
         * In the following, given C.M, then C, M or both could be defined or forward ref
         */
        /**
         * The key is C.M and the value (when defined) is the actual name.
         */
        private Map<String, String> shortFormToFull = new HashMap<String, String>();
        /**
         * Set of forward references, key/value is C.M.
          */
        private Map<String, String> forwardRefs = new HashMap<String, String>();
        /**
         * Key is C.M, value is an instance of T, but the qualified name may
         * contain a forward reference and need fixing up.
         */
        private Map<String, T> kindMap = new HashMap<String, T>();
        private final Factory<T> factory;

        ShortFormHandler(String kind, Factory<T> factory) {
            this.factory = factory;
        }

        /**
         * Gets an instance of T for short form arguments.
         * If these short forms have already been defined then the result
         * will not need fixing up later. Note that either the class or the member name
         * or both may need fixing up.
         * @param shortClassName
         * @param shortKindName
         */
        T getRecord(String shortClassName, String shortKindName) {
            ClassRecord cr = getClassRecord(shortClassName);
            String qualName = makeQualName(cr.name, shortKindName);
            String fieldName = shortFormToFull.get(qualName);
            if (fieldName == null) {
                // forward reference
                fieldName = shortKindName;
                if (forwardRefs.get(qualName) == null) {
                    // new forward reference
                    forwardRefs.put(qualName, qualName);
                }
            } else {
                qualName = cr.name + "." + fieldName;
            }
            T kindRecord = kindMap.get(qualName);
            if (kindRecord == null) {
                kindRecord = factory.create(cr, fieldName);
                kindMap.put(qualName, kindRecord);
            }
            return kindRecord;
        }

        /**
         * Definition of a member (field/method).
         */
        void define() {
            String classShortForm = recordParts[FIRST_ARG_INDEX];
            ClassRecord cr = getClassRecord(classShortForm);
            String definition = recordParts[FIRST_ARG_INDEX + 1];
            String qualName = makeQualName(cr.name, recordParts[FIRST_ARG_INDEX + 2]);
            // It would be nice if this put was definitive but since cr.name may still be forward it isn't.
            shortFormToFull.put(qualName, definition);
            // Note that if cr originally contained a forward reference but has
            // since been defined, the forwardRefs map will have been fixed up
            T t;
            if (forwardRefs.get(qualName) != null) {
                t = kindMap.remove(qualName);
                assert t != null;
                t.setName(definition);
            } else {
                // no forward refs to this member
                t = factory.create(getClassRecord(classShortForm), definition);
            }
            kindMap.put(t.getQualName(), t);
        }

        void fixup(String classShortForm, String classForwardName) {
            fixupMap(shortFormToFull, classShortForm, classForwardName);
            fixupMap(forwardRefs, classShortForm, classForwardName);
            ArrayList<AbstractMap.SimpleEntry<String, T>> toDo = new ArrayList<AbstractMap.SimpleEntry<String, T>>();
            Iterator<String> iter = kindMap.keySet().iterator();
            while (iter.hasNext())  {
                String key = iter.next();
                String[] qualNamePair = separate(key);
                if (qualNamePair[0].equals(classForwardName)) {
                    qualNamePair[0] = classShortFormsToFull.get(classShortForm).className;
                    assert qualNamePair[0] != null;
                    T def = kindMap.get(key);
                    iter.remove();
                    toDo.add(new AbstractMap.SimpleEntry<String, T>(makeQualName(qualNamePair[0], qualNamePair[1]), def));
                }
            }
            for (AbstractMap.SimpleEntry<String, T> putPair : toDo) {
                kindMap.put(putPair.getKey(), putPair.getValue());
            }
        }

        private void fixupMap(Map<String, String> map, String classShortForm, String classForwardName) {
            ArrayList<AbstractMap.SimpleEntry<String, String>> toDo = new ArrayList<AbstractMap.SimpleEntry<String, String>>();
            Iterator<String> iter = map.keySet().iterator();
            while (iter.hasNext()) {
                String key = iter.next();
                String[] qualNamePair = separate(key);
                if (qualNamePair[0].equals(classForwardName)) {
                    qualNamePair[0] = classShortFormsToFull.get(classShortForm).className;
                    assert qualNamePair[0] != null;
                    String def = map.get(key);
                    iter.remove();
                    toDo.add(new AbstractMap.SimpleEntry<String, String>(makeQualName(qualNamePair[0], qualNamePair[1]), def));
                }
            }
            for (AbstractMap.SimpleEntry<String, String> putPair : toDo) {
                map.put(putPair.getKey(), putPair.getValue());
            }
        }

        private String makeQualName(String a, String b) {
            return a + "." + b;
        }

        private String[] separate(String qualName) {
            int index = qualName.lastIndexOf('.');
            assert index > 0;
            return new String[] {qualName.substring(0, index), qualName.substring(index + 1)};
        }
    }

    private ShortFormHandler<FieldRecord> fieldShortFormHandler = new ShortFormHandler<FieldRecord>("Field", new FieldRecordFactory());
    private ShortFormHandler<MethodRecord> methodShortFormHandler = new ShortFormHandler<MethodRecord>("Method", new MethodRecordFactory());

    /**
     * List of all the records in the trace using the same format as {@link TransientVMAdviceHandlerTypes}.
     */
    private ArrayList<AdviceRecord> adviceRecordList;

    /**
     * The parts of a log record split at space boundaries.
     */
    private String[] recordParts;
    private int lineNumber;

    private ProcessLog(boolean verbose, int maxLines) throws IOException {
        this.verbose = verbose;
        this.maxLines = maxLines;
    }

    public static TraceRun processTrace(String dataDir, boolean verbose, int maxLines) throws IOException {
        ProcessLog pt = new ProcessLog(verbose, maxLines);
        return pt.doProcessTrace(dataDir);
    }

    private int estimateRecordCount(File[] files) {
        int length = 0;
        for (File file : files) {
            length += file.length();
        }
        return length / AVG_LINE_LENGTH;
    }

    private TraceRun doProcessTrace(String dataDirName) throws IOException {
        long chunkStartTime = System.currentTimeMillis();
        long processStartTime = chunkStartTime;

        File dataDir = new File(dataDirName);
        File dataFile =  null;
        if (dataDir.isDirectory()) {
            dataFile = new File(dataDir, VMAStoreFile.GLOBAL_STORE);
        } else {
            dataFile = dataDir;
        }

        int adviceRecordListCountEstimate = 0;

        if (dataFile.exists()) {
            adviceRecordListCountEstimate = estimateRecordCount(new File[] {dataFile});
        } else {
            if (dataDir.isDirectory()) {
                adviceRecordListCountEstimate = estimateRecordCount(dataDir.listFiles());
            } else {
                throw new FileNotFoundException(dataDirName);
            }
        }

        BufferedReader reader = checkTimeOrdered(dataFile);

        if (verbose) {
            System.out.println("processing trace file " + dataDirName + " starting");
        }

        adviceRecordList = new ArrayList<AdviceRecord>(adviceRecordListCountEstimate);

        lineNumber = 1;
        try {
            while (true) {
                String line = reader.readLine();
                if (line == null) {
                    break;
                }
                if (line.length() == 0 || line.charAt(0) == '#') {
                    continue;
                }
                setArgs(line);
                try {
                    processTraceRecord();
                } catch (TraceException e) {
                    System.err.println("line " + lineNumber + ": " + e);
                }
                lineNumber++;
                if (lineNumber >= maxLines) {
                    System.out.println("reached max line count - terminating processing");
                    break;
                }
                if (verbose && ((lineNumber % 100000) == 0)) {
                    long endTime = System.currentTimeMillis();
                    System.out.printf("processed %d traces in %d ms (%d)%n", lineNumber, endTime - processStartTime, endTime - chunkStartTime);
                    chunkStartTime = endTime;
                }
            }
        } finally {
            reader.close();
        }
        if (verbose) {
            System.out.println("processing trace file " + dataDirName + " complete");
        }

        // create a map from classloaders to classes loaded by them
        Map<String, SortedMap<String, ClassRecord>> classLoaders = new HashMap<String, SortedMap<String, ClassRecord>>();
        for (ClassRecord cr : classMap.values()) {
            SortedMap<String, ClassRecord> clMap = classLoaders.get(cr.getClassLoaderId());
            if (clMap == null) {
                clMap = new TreeMap<String, ClassRecord>();
                classLoaders.put(cr.getClassLoaderId(), clMap);
            }
            clMap.put(cr.getName(), cr);
        }

        fixupEndCreationRecords();

        TraceRun result = new TraceRun(dataDirName, adviceRecordList, objects, threadMap, classLoaders,
                        missingConstructors, objectCount, arrayCount,
                        missingConstructorCount, allocationEpochs, startTime, lastTime);

        return result;
    }

    private BufferedReader checkTimeOrdered(File file) throws IOException {
        BufferedReader reader = new BufferedReader(new FileReader(file));
        setArgs(reader.readLine());
        reader.close();
        assert commandMap.get(recordParts[0]) == Key.INITIALIZE_LOG;
        if (Boolean.parseBoolean(recordParts[3])) {
            // not time ordered, run the converter to a temp file
            if (verbose) {
                System.out.println("creating time ordered log from per-thread batched log");
            }
            File tempFile = File.createTempFile("vma", null);
            try {
                ConvertLog.main(new String[] {"-f", file.getAbsolutePath(), "-o", tempFile.getAbsolutePath(), "-unbatch"});
            } catch (IOException ex) {
                throw ex;
            } catch (Exception ex) {
                ProgramError.unexpected("failed to convert: " + file.getAbsolutePath(), ex);
            }
            file = tempFile;
        }
        return new BufferedReader(new FileReader(file));
    }

    /**
     * Fixup the end creation record for object records where the after <init> was a forward ref.
     */
    private void fixupEndCreationRecords() {
        for (ObjectRecord objectRecord : objects.values()) {
            if (objectRecord.endCreationRecord == null) {
                // we scan backwards to find the last <init> return
                for (int i = adviceRecordList.size() - 1; i > 0; i--) {
                    AdviceRecord ar = adviceRecordList.get(i);
                    RecordType rt = ar.getRecordType();
                    if (rt == InvokeSpecial && ar.getAdviceMode() == AdviceMode.AFTER.ordinal()) {
                        ObjectRecord invokeObject = AdviceRecordHelper.getObjectRecord(ar);
                        if (objectRecord.id.equals(invokeObject.id)) {
                            MethodRecord mr = AdviceRecordHelper.getMethod(ar);
                            if (mr.name.equals("<init>")) {
                                objectRecord.setEndCreationRecord(ar);
                            }
                        }
                    }
                }
            }
        }
    }

    private void setArgs(String line) {
        recordParts = line.split(" ");
    }

    private void objectsPut(String id, ObjectRecord td) {
        final ObjectRecord old = objects.put(td.getId(), td);
        assert old == null;
        // remember max epoch for resolving unqualified ids
        maxAllocationEpoch.put(id, allocationEpoch.epoch);
    }

    /**
     * Gets the {@link ObjectRecord} associated with an unqualified id. The qualified id is found using the
     * {@link #maxEpochMap}.
     *
     * @param id
     * @throws TraceException
     */
    private ObjectRecord getTraceRecord(String id) throws TraceException {
        if (id.equals("0")) {
            return null;
        }
        final Integer thisMaxAllocationEpoch = maxAllocationEpoch.get(id);
        assert thisMaxAllocationEpoch != null;
        final String uid = ObjectRecord.getMapId(id, thisMaxAllocationEpoch);
        ObjectRecord td = objects.get(uid);
        if (td == null) {
            throw new TraceException("no creation record for id = " + uid + ", at line " + lineNumber);
        }
        td.traceOccurrences++;
        return td;
    }

    /**
     * Sets (and returns) {@link #classRecord}, handling forward references.
     * In the latter case, the name field in the ClassRecord will be based on {@value CLASS_FORWARD_PREFIX}
     * and will be fixed up later.
     * @param shortClassName in the trace
     * @return a {@link ClassRecord}
     */
    private ClassRecord getClassRecord(String shortClassName) {
        ClassNameId classNameId = classShortFormsToFull.get(shortClassName);
        if (classNameId == null) {
            // forward reference
            classNameId = classForwardsMap.get(shortClassName);
            if (classNameId == null) {
                // new forward reference
                String forwardName = CLASS_FORWARD_PREFIX + shortClassName;
                // the class definition will contain the classloader id;
                // at this stage we create a don't care value, as it isn't used
                classNameId = new ClassNameId(forwardName, ObjectRecord.getMapId("0", allocationEpoch.epoch));
                classForwardsMap.put(shortClassName, classNameId);
            }
        }
        // Have we created a ClassRecord for this class?
        classRecord = classMap.get(classNameId);
        if (classRecord == null) {
            classRecord = new ClassRecord(classNameId.className, classNameId.clId);
            classMap.put(classNameId, classRecord);
        }
        return classRecord;
    }

    /*
     */

    /**
     * Sets (and returns) {@link #fieldRecord} handling forward references.
     *
     * @param shortClassName
     * @param shortFieldName
     */
    private FieldRecord getFieldRecord(String shortClassName, String shortFieldName) {
        fieldRecord = fieldShortFormHandler.getRecord(shortClassName, shortFieldName);
        return fieldRecord;
    }

    /**
     * Sets (and returns) {@link #methodRecord} handling forward references.
     *
     * @param shortClassName
     * @param shortMethodName
     */
    private MethodRecord getMethodRecord(String shortClassName, String shortMethodName) {
        methodRecord = methodShortFormHandler.getRecord(shortClassName, shortMethodName);
        return methodRecord;
    }

    /**
     * Class definition, may resolve a previous forward reference.
     */
    private void defineClass(String name, long classLoaderId, String shortForm) {
        // class definition
        ClassNameId classNameId = new ClassNameId(name, getClassLoaderIdAsString(classLoaderId));
        classShortFormsToFull.put(shortForm, classNameId);
        // fix up forward reference
        ClassNameId forwardName = classForwardsMap.get(shortForm);
        if (forwardName != null) {
            // find class record in the classMap under the forward name, remove it,
            // patch name/id and add back under new name.
            ClassRecord cr = classMap.remove(forwardName);
            assert cr != null;
            cr.setName(name, getClassLoaderIdAsString(classLoaderId));
            classMap.put(classNameId, cr);
            fieldShortFormHandler.fixup(shortForm, forwardName.className);
            methodShortFormHandler.fixup(shortForm, forwardName.className);
        }
    }

    private String getClassLoaderIdAsString(long clId) {
        String clIdString = Long.toString(clId);
        Integer epoch = maxAllocationEpoch.get(clIdString);
        if (epoch == null) {
            // This is a special case for the self referring bootstrap class loader
            epoch = allocationEpoch.epoch;
        }
        return ObjectRecord.getMapId(Long.toString(clId), epoch);
    }

    private void defineField() {
        fieldShortFormHandler.define();
    }

    private void defineMethod() {
        methodShortFormHandler.define();
    }

    private long getTime() throws TraceException {
        long timeValue = Long.parseLong(recordParts[TIME_INDEX]);
        if (absTime) {
            lastTime = timeValue;
        } else {
            lastTime += timeValue;
        }
        return lastTime;
    }

    private long expectNumber(String arg) throws TraceException {
        if (!(arg.charAt(0) >= '0' || arg.charAt(0) <= '9')) {
            throw new TraceException("number expected at line " + lineNumber);
        } else {
            return Long.parseLong(arg);
        }
    }

    private Key expectValidTraceStart() throws TraceException {
        Key result = commandMap.get(recordParts[KEY_INDEX]);
        if (result == null) {
            throw new TraceException("unknown trace command at line " + lineNumber);
        } else {
            return result;
        }
    }

    private void getTimeAndThread() throws TraceException {
        getTime();
        // N.B. there can be no forward references to threads
        String threadName = threadShortFormsToFull.get(recordParts[THREAD_INDEX]);
        assert threadName != null;
        threadRecord = threadMap.get(threadName);

    }

    private void processTraceRecord() throws TraceException {
        String arg1 = recordParts[1];
        String arg2 = recordParts.length > 2 ? recordParts[2] : null;
        String arg3 = recordParts.length > 3 ? recordParts[3] : null;
        String arg4 = recordParts.length > 4 ? recordParts[4] : null;
        String arg5 = recordParts.length > 5 ? recordParts[5] : null;
        String arg6 = recordParts.length > 6 ? recordParts[6] : null;
        String logTimeArg = arg1;
        String threadArg = arg2;
        String objIdArg = "???";
        int adviceModeInt = -1;

        Key key = commandMap.get(recordParts[0]);

        if (CVMATextStore.hasTimeAndThread(key)) {
            getTimeAndThread();
        } else if (CVMATextStore.hasTime(key)) {
            getTime();
        }

        if (CVMATextStore.hasId(key)) {
            if (arg3.charAt(0) == REPEAT_ID) {
                objIdArg = lastId.get(threadArg);
            } else {
                objIdArg = arg3;
                lastId.put(threadArg, objIdArg);
            }
        }

        AdviceRecord adviceRecord = null;

        switch (key) {
            case INITIALIZE_LOG:
                startTime = Long.parseLong(logTimeArg);
                lastTime = startTime;
                allocationEpoch = new AllocationEpoch(startTime);
                allocationEpochs.add(allocationEpoch);
                absTime = Boolean.parseBoolean(arg2);
                return;

            case FINALIZE_LOG:
                lastTime = Long.parseLong(logTimeArg);
                allocationEpoch.endTime = lastTime;
                return;

            case THREAD_SWITCH:
                throw new TraceException("batched log is not supported - use ConvertLog -unbatch");

            case CLASS_DEFINITION: {
                defineClass(ClassRecord.getCanonicalName(arg1), expectNumber(arg2), arg3);
                return;
            }

            case FIELD_DEFINITION: {
                defineField();
                return;
            }

            case METHOD_DEFINITION: {
                defineMethod();
                return;
            }

            case THREAD_DEFINITION: {
                ThreadRecord tr = new ThreadRecord(recordParts[FIRST_ARG_INDEX]);
                threadMap.put(tr.name, tr);
                threadShortFormsToFull.put(recordParts[FIRST_ARG_INDEX + 1], tr.name);
                return;
            }

            case ADVISE_BEFORE_THROW:
            case ADVISE_BEFORE_MONITOR_ENTER:
            case ADVISE_BEFORE_MONITOR_EXIT: {
                objectRecord = getTraceRecord(objIdArg);
                ObjectAdviceRecord objectAdviceRecord = (ObjectAdviceRecord) createAdviceRecordAndSetTimeAndThread(keyToRecordType(key), AdviceMode.BEFORE);
                objectAdviceRecord.value = objectRecord;
                adviceRecord = objectAdviceRecord;
                break;
            }

            case UNSEEN:
            case ADVISE_AFTER_NEW_ARRAY:
            case ADVISE_AFTER_NEW: {
                ObjectAdviceRecord objectAdviceRecord = (ObjectAdviceRecord) createAdviceRecordAndSetTimeAndThread(keyToRecordType(key), AdviceMode.AFTER);
                getClassRecord(recordParts[ID_CLASSNAME_INDEX]);
                objectRecord = new ObjectRecord(objIdArg, allocationEpoch.epoch, classRecord, threadRecord, objectAdviceRecord);
                classRecord.addObject(objectRecord);
                objectsPut(objIdArg, objectRecord);
                objectAdviceRecord.value = objectRecord;
                if (key == Key.UNSEEN) {
                    // We don't know how or when this was constructed, but give it an end creation time of now.
                    objectRecord.setEndCreationRecord(objectAdviceRecord);
                    missingConstructors.put(objectRecord.getId(), objectRecord);
                    missingConstructorCount++;
                } else if (key == Key.ADVISE_AFTER_NEW_ARRAY) {
                    objectAdviceRecord.setPackedValue(Integer.parseInt(arg4)); // array length
                    objectRecord.setEndCreationRecord(objectAdviceRecord);
                }
                if (classRecord.isArray()) {
                    arrayCount++;
                } else {
                    objectCount++;
                }
                adviceRecord = objectAdviceRecord;
                break;
            }

            case ADVISE_BEFORE_CONST_LOAD: {
                adviceRecord = createAdviceRecordAndSetTimeThreadValue("ConstLoad", AdviceMode.BEFORE, arg3, arg4);
                break;
            }

            case ADVISE_BEFORE_LOAD: {
                adviceRecord = createAdviceRecordAndSetTimeAndThread(Load, AdviceMode.BEFORE);
                adviceRecord.setPackedValue(Integer.parseInt(arg3));
                break;
            }

            case ADVISE_BEFORE_STORE: {
                adviceRecord = createAdviceRecordAndSetTimeThreadValue("Store", AdviceMode.BEFORE, arg4, arg5);
                adviceRecord.setPackedValue(Integer.parseInt(arg3));
                break;
            }

            case ADVISE_BEFORE_ARRAY_LOAD: {
                objectRecord = getTraceRecord(objIdArg);
                int arrayIndex = (int) expectNumber(recordParts[ARRAY_INDEX_INDEX]);
                ObjectAdviceRecord objectAdviceRecord = (ObjectAdviceRecord) createAdviceRecordAndSetTimeAndThread(keyToRecordType(key), AdviceMode.BEFORE);
                objectAdviceRecord.value = objectRecord;
                objectAdviceRecord.setPackedValue(arrayIndex);
                objectRecord.addTraceElement(objectAdviceRecord);
                adviceRecord = objectAdviceRecord;
                break;
            }

            case ADVISE_BEFORE_ARRAY_STORE: {
                objectRecord = getTraceRecord(objIdArg);
                int arrayIndex = (int) expectNumber(recordParts[ARRAY_INDEX_INDEX]);
                ObjectAdviceRecord objectAdviceRecord = (ObjectAdviceRecord) createAdviceRecordAndSetTimeThreadValue("ArrayStore", AdviceMode.BEFORE, recordParts[ARRAY_INDEX_INDEX + 1], recordParts[ARRAY_INDEX_INDEX + 2]);
                objectAdviceRecord.value = objectRecord;
                objectAdviceRecord.setPackedValue(arrayIndex);
                objectRecord.addTraceElement(objectAdviceRecord);
                adviceRecord = objectAdviceRecord;
                break;
            }

            case ADVISE_BEFORE_ARRAY_LENGTH: {
                objectRecord = getTraceRecord(objIdArg);
                ObjectAdviceRecord objectAdviceRecord = (ObjectAdviceRecord) createAdviceRecordAndSetTimeAndThread(ArrayLength, AdviceMode.BEFORE);
                objectAdviceRecord.value = objectRecord;
                objectAdviceRecord.setPackedValue(Integer.parseInt(arg4));
                objectRecord.addTraceElement(objectAdviceRecord);
                adviceRecord = objectAdviceRecord;
                break;
            }


            case ADVISE_BEFORE_GET_STATIC: {
                getFieldRecord(recordParts[STATIC_CLASSNAME_INDEX], recordParts[STATIC_CLASSNAME_INDEX + 1]);
                ObjectFieldAdviceRecord objectFieldAdviceRecord = (ObjectFieldAdviceRecord) createAdviceRecordAndSetTimeAndThread(GetStatic, AdviceMode.BEFORE);
                objectFieldAdviceRecord.value = classRecord;
                objectFieldAdviceRecord.field = fieldRecord;
                classRecord.addTraceElement(objectFieldAdviceRecord);
                adviceRecord = objectFieldAdviceRecord;
                break;
            }

            case ADVISE_BEFORE_PUT_STATIC: {
                getFieldRecord(recordParts[STATIC_CLASSNAME_INDEX], recordParts[STATIC_CLASSNAME_INDEX + 1]);
                ObjectFieldAdviceRecord objectFieldAdviceRecord = (ObjectFieldAdviceRecord) createAdviceRecordAndSetTimeThreadValue("PutStatic", AdviceMode.BEFORE, recordParts[STATIC_CLASSNAME_INDEX + 2], recordParts[STATIC_CLASSNAME_INDEX + 3]);
                objectFieldAdviceRecord.value = classRecord;
                objectFieldAdviceRecord.field = fieldRecord;
                classRecord.addTraceElement(objectFieldAdviceRecord);
                adviceRecord = objectFieldAdviceRecord;
                break;
            }

            case ADVISE_BEFORE_GET_FIELD: {
                objectRecord = getTraceRecord(objIdArg);
                getFieldRecord(recordParts[ID_CLASSNAME_INDEX], recordParts[ID_CLASSNAME_INDEX + 1]);
                ObjectFieldAdviceRecord objectFieldAdviceRecord = (ObjectFieldAdviceRecord) createAdviceRecordAndSetTimeAndThread(GetField, AdviceMode.BEFORE);
                objectFieldAdviceRecord.value = objectRecord;
                objectFieldAdviceRecord.field = fieldRecord;
                objectRecord.addTraceElement(objectFieldAdviceRecord);
                adviceRecord = objectFieldAdviceRecord;
                break;
            }

            case ADVISE_BEFORE_PUT_FIELD: {
                objectRecord = getTraceRecord(objIdArg);
                getFieldRecord(recordParts[ID_CLASSNAME_INDEX], recordParts[ID_CLASSNAME_INDEX + 1]);
                ObjectFieldAdviceRecord objectFieldAdviceRecord = (ObjectFieldAdviceRecord) createAdviceRecordAndSetTimeThreadValue("PutField", AdviceMode.BEFORE, recordParts[ID_CLASSNAME_INDEX + 2], recordParts[ID_CLASSNAME_INDEX + 3]);
                objectFieldAdviceRecord.value = objectRecord;
                objectFieldAdviceRecord.field = fieldRecord;
                objectRecord.addTraceElement(objectFieldAdviceRecord);
                adviceRecord = objectFieldAdviceRecord;
                break;
            }

            case ADVISE_BEFORE_IF: {
                if (arg4.equals("J")) {
                    LongLongAdviceRecord longLongAdviceRecord = (LongLongAdviceRecord) createAdviceRecordAndSetTimeAndThread(IfInt, AdviceMode.BEFORE);
                    longLongAdviceRecord.value = Long.parseLong(arg5);
                    longLongAdviceRecord.value2 = Long.parseLong(arg6);
                    adviceRecord = longLongAdviceRecord;
                } else {
                    ObjectObjectAdviceRecord objectObjectAdviceRecord = (ObjectObjectAdviceRecord) createAdviceRecordAndSetTimeAndThread(IfObject, AdviceMode.BEFORE);
                    objectObjectAdviceRecord.value = getTraceRecord(arg5);
                    objectObjectAdviceRecord.value2 = getTraceRecord(arg6);
                    adviceRecord = objectObjectAdviceRecord;
                }
                adviceRecord.setPackedValue(Integer.parseInt(arg3));
                break;
            }
            case ADVISE_BEFORE_OPERATION: {
                adviceRecord = createAdviceRecordAndSetTimeThreadValue("Operation", AdviceMode.BEFORE, arg4, arg5);
                adviceRecord.setPackedValue(Integer.parseInt(arg3));
                switch (arg4.charAt(0)) {
                    case LONG_VALUE:
                        ((LongLongAdviceRecord) adviceRecord).value2 = Long.parseLong(arg6);
                        break;
                    case FLOAT_VALUE:
                        ((FloatFloatAdviceRecord) adviceRecord).value2 = Float.parseFloat(arg6);
                        break;
                    case DOUBLE_VALUE:
                        ((DoubleDoubleAdviceRecord) adviceRecord).value2 = Double.parseDouble(arg6);
                        break;
                    default:
                        throw new IllegalArgumentException("bad type " + arg4.charAt(0) + " in value");
                }
                break;
            }

            case ADVISE_BEFORE_INSTANCE_OF:
            case ADVISE_BEFORE_CHECK_CAST:  {
                objectRecord = getTraceRecord(objIdArg);
                ObjectObjectAdviceRecord objectObjectAdviceRecord = (ObjectObjectAdviceRecord) createAdviceRecordAndSetTimeAndThread(keyToRecordType(key), AdviceMode.BEFORE);
                objectObjectAdviceRecord.value = objectRecord;
                objectObjectAdviceRecord.value = classRecord;
                if (objectRecord != null) {
                    objectRecord.addTraceElement(objectObjectAdviceRecord);
                }
                adviceRecord = objectObjectAdviceRecord;
                break;
            }

            case ADVISE_BEFORE_CONVERSION: {
                adviceRecord = createAdviceRecordAndSetTimeThreadValue("Conversion", AdviceMode.BEFORE, arg4, arg5);
                adviceRecord.setPackedValue(Integer.parseInt(arg3));
                break;
            }

            case ADVISE_BEFORE_GC: {
                allocationEpoch.setEndTime(lastTime);
                adviceRecord = createAdviceRecordAndSetTimeAndThread(keyToRecordType(key), AdviceMode.BEFORE);
                break;
            }

            case ADVISE_AFTER_GC: {
                prevAllocationEpoch = allocationEpoch;
                allocationEpoch = new AllocationEpoch(lastTime);
                allocationEpochs.add(allocationEpoch);
                adviceRecord = createAdviceRecordAndSetTimeAndThread(keyToRecordType(key), AdviceMode.AFTER);
                break;
            }

            case REMOVAL: {
                if (startRemoval < 0) {
                    startRemoval = adviceRecordList.size();
                }
                endRemoval = adviceRecordList.size();
                objIdArg = arg1;
                // This object may have been created in some earlier epoch, so can't use current.
                // It must be the death of id recorded by maxAllocationEpoch
                objectRecord = objects.get(ObjectRecord.getMapId(objIdArg, maxAllocationEpoch.get(objIdArg)));
                ObjectAdviceRecord objectAdviceRecord = (ObjectAdviceRecord) createAdviceRecordAndSetTimeAndThread(Removal, AdviceMode.AFTER);
                objectAdviceRecord.value = objectRecord;
                objectRecord.setRemovalRecord(objectAdviceRecord);
                adviceRecord = objectAdviceRecord;
                break;
            }

            case ADVISE_BEFORE_INVOKE_INTERFACE:
            case ADVISE_BEFORE_INVOKE_STATIC:
            case ADVISE_BEFORE_INVOKE_VIRTUAL:
            case ADVISE_BEFORE_INVOKE_SPECIAL:
                adviceModeInt = AdviceMode.BEFORE.ordinal();
            // Checkstyle: stop
            case ADVISE_AFTER_METHOD_ENTRY:
            case ADVISE_AFTER_INVOKE_INTERFACE:
            case ADVISE_AFTER_INVOKE_STATIC:
            case ADVISE_AFTER_INVOKE_VIRTUAL:
            case ADVISE_AFTER_INVOKE_SPECIAL: {
                // Checkstyle: resume
                if (adviceModeInt == -1) {
                    adviceModeInt = AdviceMode.AFTER.ordinal();
                }
                objectRecord = getTraceRecord(objIdArg);
                getMethodRecord(recordParts[ID_CLASSNAME_INDEX], recordParts[ID_CLASSNAME_INDEX + 1]);
                ObjectMethodAdviceRecord objectAdviceRecord = (ObjectMethodAdviceRecord) createAdviceRecordAndSetTimeAndThread(keyToRecordType(key), AdviceMode.values()[adviceModeInt]);
                if (key == Key.ADVISE_BEFORE_INVOKE_STATIC || key == Key.ADVISE_AFTER_INVOKE_STATIC) {
                    objectAdviceRecord.value = classRecord;
                } else {
                    objectAdviceRecord.value = objectRecord;
                }
                objectAdviceRecord.value2 = methodRecord;
                if (key == Key.ADVISE_AFTER_INVOKE_SPECIAL) {
                    if (methodRecord.name.equals("<init>")) {
                        objectRecord.setEndCreationRecord(objectAdviceRecord);
                    }
                }
                adviceRecord = objectAdviceRecord;
                break;
            }

            case ADVISE_BEFORE_RETURN: {
                if (arg3 != null) {
                    adviceRecord = createAdviceRecordAndSetTimeThreadValue("Return", AdviceMode.BEFORE, arg3, arg4);
                } else {
                    adviceRecord = createAdviceRecordAndSetTimeAndThread(Return, AdviceMode.BEFORE);
                }
                break;
            }

            case ADVISE_BEFORE_RETURN_BY_THROW: {
                objectRecord = getTraceRecord(objIdArg);
                ObjectLongAdviceRecord objectAdviceRecord = (ObjectLongAdviceRecord) createAdviceRecordAndSetTimeAndThread(ReturnByThrow, AdviceMode.BEFORE);
                objectAdviceRecord.setPackedValue(Integer.parseInt(arg4));
                objectAdviceRecord.value = objectRecord;
                adviceRecord = objectAdviceRecord;
                break;
            }

            case ADVISE_BEFORE_STACK_ADJUST: {
                adviceRecord = createAdviceRecordAndSetTimeAndThread(keyToRecordType(key), AdviceMode.BEFORE);
                adviceRecord.setPackedValue(Integer.parseInt(arg3));
                break;
            }

            case ADVISE_BEFORE_THREAD_TERMINATING:
            case ADVISE_BEFORE_THREAD_STARTING:
                // nothing else
                break;

            case ADVISE_AFTER_MULTI_NEW_ARRAY:
                assert false : key + " unexpected";
                break;

            case ADVISE_BEFORE_BYTECODE:
                adviceRecord = createAdviceRecordAndSetTimeAndThread(keyToRecordType(key), AdviceMode.BEFORE);
                adviceRecord.setPackedValue(Integer.parseInt(arg3));
                break;

            default:
                throw new TraceException("unimplemented key: " + key);
        }


        if (key != Key.REMOVAL && startRemoval >= 0) {
            prevAllocationEpoch.setRemovalRange(startRemoval, endRemoval);
            startRemoval = -1;
        }
        assert adviceRecord != null;
        adviceRecordList.add(adviceRecord);
    }

    private AdviceRecord createAdviceRecordAndSetTimeThreadValue(String rtPrefix, AdviceMode adviceMode, String valueKey, String value) throws TraceException {
        RecordType rt = getRecordTypeForValue(rtPrefix, valueKey);
        AdviceRecord adviceRecord = createAdviceRecordAndSetTimeAndThread(rt, adviceMode);
        switch (valueKey.charAt(0)) {
            case OBJ_VALUE: {
                ObjectRecord or = getTraceRecord(value);
                switch (rt) {
                    case PutFieldObject:
                    case PutStaticObject:
                        ((ObjectFieldObjectAdviceRecord) adviceRecord).value = or;
                        break;
                    case ConstLoadObject:
                    case StoreObject:
                    case ReturnObject:
                        ((ObjectAdviceRecord) adviceRecord).value = or;
                        break;
                    default:
                        ((ObjectObjectAdviceRecord) adviceRecord).value2 = or;
                }
                break;
            }

            case LONG_VALUE: {
                long v = Long.parseLong(value);
                switch (rt) {
                    case PutFieldLong:
                    case PutStaticLong:
                        ((ObjectFieldLongAdviceRecord) adviceRecord).value2 = v;
                        break;
                    case ConstLoadLong:
                    case StoreLong:
                    case ConversionLong:
                    case ReturnLong:
                        ((LongAdviceRecord) adviceRecord).value = v;
                        break;
                    case OperationLong:
                        ((LongLongAdviceRecord) adviceRecord).value = v;
                        break;
                    default:
                        ((ObjectLongAdviceRecord) adviceRecord).value2 = v;
                }
                break;
            }

            case FLOAT_VALUE: {
                float v = Float.parseFloat(value);
                switch (rt) {
                    case PutFieldFloat:
                    case PutStaticFloat:
                        ((ObjectFieldFloatAdviceRecord) adviceRecord).value2 = v;
                        break;
                    case ConstLoadFloat:
                    case StoreFloat:
                    case ConversionFloat:
                    case ReturnFloat:
                        ((FloatAdviceRecord) adviceRecord).value = v;
                        break;
                    case OperationFloat:
                        ((FloatFloatAdviceRecord) adviceRecord).value = v;
                        break;
                    default:
                        ((ObjectFloatAdviceRecord) adviceRecord).value2 = v;
                }
                break;
            }

            case DOUBLE_VALUE: {
                double v = Double.parseDouble(value);
                switch (rt) {
                    case PutFieldDouble:
                    case PutStaticDouble:
                        ((ObjectFieldDoubleAdviceRecord) adviceRecord).value2 = v;
                        break;
                    case ConstLoadDouble:
                    case StoreDouble:
                    case ConversionDouble:
                    case ReturnDouble:
                        ((DoubleAdviceRecord) adviceRecord).value = v;
                        break;
                    case OperationDouble:
                        ((DoubleDoubleAdviceRecord) adviceRecord).value = v;
                        break;
                    default:
                        ((ObjectDoubleAdviceRecord) adviceRecord).value2 = v;
                }
                break;
            }

            default:
                assert false;

        }
        return adviceRecord;
    }

    private AdviceRecord createAdviceRecordAndSetTimeAndThread(RecordType rt, AdviceMode adviceMode) {
        AdviceRecord adviceRecord;
        // Handle the change of record type for PUT/GET/FIELD/STATIC and REMOVAL types
        switch (rt) {
            case PutFieldLong:
            case PutStaticLong:
                adviceRecord = new ObjectFieldLongAdviceRecord();
                break;
            case PutFieldFloat:
            case PutStaticFloat:
                adviceRecord = new ObjectFieldFloatAdviceRecord();
                break;
            case PutFieldDouble:
            case PutStaticDouble:
                adviceRecord = new ObjectFieldDoubleAdviceRecord();
                break;

            case PutFieldObject:
            case PutStaticObject:
                adviceRecord = new ObjectFieldObjectAdviceRecord();
                break;

            case GetField:
            case GetStatic:
                adviceRecord = new ObjectFieldAdviceRecord();
                break;

            case Removal:
                adviceRecord = new ObjectAdviceRecord();
                break;

            default:
                adviceRecord = rt.newAdviceRecord();
        }
        adviceRecord.setCodeAndMode(rt, adviceMode.ordinal());
        adviceRecord.time = lastTime;
        adviceRecord.thread = threadRecord;
        return adviceRecord;
    }

    private static RecordType getRecordTypeForValue(String rtPrefix, String valueKey) {
        String suffix;
        switch (valueKey.charAt(0)) {
            case OBJ_VALUE:
                suffix = "Object";
                break;
            case LONG_VALUE:
                suffix = "Long";
                break;
            case FLOAT_VALUE:
                suffix = "Float";
                break;
            case DOUBLE_VALUE:
                suffix = "Double";
                break;
            default:
                throw new IllegalArgumentException("bad type " + valueKey.charAt(0) + " in value");
        }
        return RecordType.valueOf(rtPrefix + suffix);
    }

    private static RecordType keyToRecordType(Key key) throws TraceException {
        switch (key) {
            case ADVISE_BEFORE_THROW:
                return Throw;
            case ADVISE_BEFORE_INSTANCE_OF:
                return InstanceOf;
            case ADVISE_BEFORE_ARRAY_LENGTH:
                return ArrayLength;
            case ADVISE_BEFORE_CHECK_CAST:
                return CheckCast;
            case ADVISE_BEFORE_GET_STATIC:
                return GetStatic;
            case ADVISE_BEFORE_GET_FIELD:
                return GetField;

            case ADVISE_BEFORE_MONITOR_ENTER:
                return MonitorEnter;
            case ADVISE_BEFORE_MONITOR_EXIT:
                return MonitorExit;

            case ADVISE_AFTER_INVOKE_INTERFACE:
            case ADVISE_BEFORE_INVOKE_INTERFACE:
                return InvokeInterface;
            case ADVISE_AFTER_INVOKE_STATIC:
            case ADVISE_BEFORE_INVOKE_STATIC:
                return InvokeStatic;
            case ADVISE_AFTER_INVOKE_SPECIAL:
            case ADVISE_BEFORE_INVOKE_SPECIAL:
                return InvokeSpecial;
            case ADVISE_BEFORE_INVOKE_VIRTUAL:
            case ADVISE_AFTER_INVOKE_VIRTUAL:
                return InvokeVirtual;

            case ADVISE_AFTER_METHOD_ENTRY:
                return MethodEntry;

            case ADVISE_BEFORE_STACK_ADJUST:
                return StackAdjust;

            case ADVISE_AFTER_GC:
            case ADVISE_BEFORE_GC:
                return GC;
            case ADVISE_BEFORE_THREAD_TERMINATING:
            case ADVISE_BEFORE_THREAD_STARTING:
            case ADVISE_BEFORE_CONST_LOAD:
                break;

            case ADVISE_BEFORE_ARRAY_LOAD:
                return ArrayLoad;

            case ADVISE_AFTER_NEW:
                return New;
            case ADVISE_AFTER_NEW_ARRAY:
                return NewArray;

            case REMOVAL:
                return Removal;
            case UNSEEN:
                return Unseen;

            case ADVISE_BEFORE_RETURN:
                return Return;

            case ADVISE_BEFORE_BYTECODE:
                return Bytecode;

            case ADVISE_AFTER_MULTI_NEW_ARRAY:
                // These are all value based so do not have a simple static mapping
            case ADVISE_BEFORE_CONVERSION:
            case ADVISE_BEFORE_PUT_FIELD:
            case ADVISE_BEFORE_PUT_STATIC:
            case ADVISE_BEFORE_ARRAY_STORE:
            case ADVISE_BEFORE_IF:
            case ADVISE_BEFORE_OPERATION:
            case ADVISE_BEFORE_LOAD:
            case ADVISE_BEFORE_STORE:

        }
        throw new TraceException("unimplemented case");
    }

    public static void main(String[] args) {
        QueryAnalysis.main(args);
    }

}

