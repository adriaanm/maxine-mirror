/*
 * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.oracle.max.vma.tools.qa;

import static com.oracle.max.vm.ext.vma.log.txt.TextVMAdviceHandlerLog.*;

import java.io.*;
import java.util.*;

import com.oracle.max.vm.ext.vma.log.txt.*;

/**
 * Reads a log file in the format generated by {@link CompactTextObjectTrackerLog}.
 *
 * Object identifiers in the log may be reused owing to garbage collection. Object identifiers in the {@link #objects}
 * map are unique and always qualified by the allocation (gc) epoch, {@link #gcEpoch). I.e., an id X in the log is
 * stored as "X:gcEpoch", e.g. "X:0, X:3, ..."
 *
 * The log may not be time ordered in that the events for separate threads may be batched together. However, in this
 * case, each batch starts with a {@link RESET_TIME_ID} event that sets the start time for the batch, allowing proper
 * time management.
 *
 * Note that although the map may contain many instances of X:n, at any point in time there can only be one active
 * instance, which is the value of "n" given by the {@link #maxEpoch} map. Note also, in logs that are not time ordered
 * it is not entirely trivial to map an unqualified id to the correct definition, since a use may precede its definition
 * (construction). This is resolved by correlating the time of the event and the time of the gc epochs.
 *
 * N.B. Currently non-time ordered logs cannot be handled by this code. They must first be processed with
 * {@link ConvertLog}.
 *
 */
public class ProcessLog {

    static class TraceException extends Exception {

        static final long serialVersionUID = 0;

        TraceException(String s) {
            super(s);
        }
    }

    static class ClassNameId implements Comparable {

        String className;
        String clId;

        ClassNameId(String name, String id) {
            this.className = name;
            this.clId = id;
        }

        public int compareTo(Object other) {
            ClassNameId otherClassName = (ClassNameId) other;
            if (otherClassName.className.equals(className)) {
                return clId.compareTo(otherClassName.clId);
            } else {
                return className.compareTo(otherClassName.className);
            }
        }

        @Override
        public int hashCode() {
            return className.hashCode() ^ clId.hashCode();
        }

        @Override
        public boolean equals(Object other) {
            return compareTo(other) == 0;
        }
    }

    private boolean verbose = false;
    private boolean prettyTrace;
    private int maxLines;

    String dataFile;

    private Map<String, ObjectRecord> objects = new HashMap<String, ObjectRecord>(1024 * 1024);

    private SortedMap<ClassNameId, ClassRecord> classMap = new TreeMap<ClassNameId, ClassRecord>();
    private Map<String, ThreadRecord> threadMap = new HashMap<String, ThreadRecord>();
    private Map<String, FieldRecord> fieldMap = new HashMap<String, FieldRecord>();
    private Map<String, MethodRecord> methodMap = new HashMap<String, MethodRecord>();

    private ArrayList<GCEpoch> gcEpochs = new ArrayList<GCEpoch>();

    private long objectCount = 0;

    private long arrayCount = 0;

    private int missingConstructorCount = 0;

    private long startTime; // absolute value in trace
    private long lastTime; // relative value starting at zero
    private GCEpoch gcEpoch;
    private Map<String, Integer> maxEpoch = new HashMap<String, Integer>();
    private Map<ThreadRecord, String> lastId = new HashMap<ThreadRecord, String>();

    // Following fields hold the values for the current trace (if appropriate)
    private ObjectRecord objectRecord;
    private FieldRecord fieldRecord;
    private MethodRecord methodRecord;
    private ThreadRecord threadRecord;
    private ClassRecord classRecord;

    private Map<String, ObjectRecord> missingConstructors = new HashMap<String, ObjectRecord>();

    private Map<String, ClassNameId> classShortForms = new HashMap<String, ClassNameId>();
    private Map<String, String> fieldShortForms = new HashMap<String, String>();
    private Map<String, String> methodShortForms = new HashMap<String, String>();
    private Map<String, String> threadShortForms = new HashMap<String, String>();
    private Map<String, String> arrayIndices = new HashMap<String, String>(); // intern string table for array indices

    private Map<String, ClassNameId> classForwardsMap = new HashMap<String, ClassNameId>();
    private Map<String, String> fieldForwardsMap = new HashMap<String, String>();
    private Map<String, String> methodForwardsMap = new HashMap<String, String>();
    private static final String FIELD_FORWARD_PREFIX = "FieldForward:";
    private static final String CLASS_FORWARD_PREFIX = "ClassForward:";
    private static final String METHOD_FORWARD_PREFIX = "MethodForward:";

    private ArrayList<LogRecord> adviceRecordList = new ArrayList<LogRecord>();

    /**
     * The parts of a log record split at space boundaries.
     */
    private String[] recordParts;
    private int lineNumber;

    private ProcessLog(String dataFile, boolean verbose, boolean prettyTrace, int maxLines) throws IOException {
        this.dataFile = dataFile;
        this.verbose = verbose;
        this.prettyTrace = prettyTrace;
        this.maxLines = maxLines;
    }

    public static TraceRun processTrace(String dataFile, boolean verbose, boolean prettyTrace, int maxLines) throws IOException {
        ProcessLog pt = new ProcessLog(dataFile, verbose, prettyTrace, maxLines);
        return pt.doProcessTrace();
    }

    private TraceRun doProcessTrace() throws IOException {
        long startTime = System.currentTimeMillis();
        long chunkStartTime = startTime;

        if (verbose) {
            System.out.println("processing trace file " + dataFile + " starting");
        }

        BufferedReader reader = new BufferedReader(new FileReader(dataFile));
        lineNumber = 1;
        try {
            while (true) {
                String line = reader.readLine();
                if (line == null) {
                    break;
                }
                if (line.length() == 0) {
                    continue;
                }
                setArgs(line);
                processTraceRecord();
                lineNumber++;
                if (lineNumber >= maxLines) {
                    System.out.println("reached max line count - terminating processing");
                    break;
                }
                if (verbose && ((lineNumber % 100000) == 0)) {
                    long endTime = System.currentTimeMillis();
                    System.out.println("processed " + lineNumber + " traces in " + (endTime - startTime) + " ms " + "(" + (endTime - chunkStartTime) + ")");
                    chunkStartTime = endTime;
                }
            }
        } finally {
            reader.close();
        }
        if (verbose) {
            System.out.println("processing trace file " + dataFile + " complete");
        }

        // create a map from classloaders to classes loaded by them
        Map<String, SortedMap<String, ClassRecord>> classLoaders = new HashMap<String, SortedMap<String, ClassRecord>>();
        for (ClassRecord cr : classMap.values()) {
            SortedMap<String, ClassRecord> clMap = classLoaders.get(cr.getClassLoaderId());
            if (clMap == null) {
                clMap = new TreeMap<String, ClassRecord>();
                classLoaders.put(cr.getClassLoaderId(), clMap);
            }
            clMap.put(cr.getName(), cr);
        }

        TraceRun result = new TraceRun(dataFile, objects, classLoaders, missingConstructors, objectCount, arrayCount, missingConstructorCount, gcEpochs, lastTime);

        return result;
    }

    private void setArgs(String line) {
        recordParts = line.split(" ");
    }

    private void processTraceRecord() throws IOException {
        try {
            String id = null;
            Key traceCommand = expectValidTraceStart();
            adviceRecordList.add(new LogRecord(traceCommand));

            if (TextVMAdviceHandlerLog.hasTimeAndThread(traceCommand)) {
                getTimeAndThread();
            }
            if (TextVMAdviceHandlerLog.hasId(traceCommand)) {
                if (recordParts[OBJ_ID_INDEX].charAt(0) == REPEAT_ID) {
                    id = lastId.get(threadRecord);
                } else {
                    // The id gets the gc epoch qualification later
                    id = recordParts[OBJ_ID_INDEX];
                    lastId.put(threadRecord, id);
                }
            }
            switch (traceCommand) {
                case INITIALIZE_LOG:
                    startTime = Long.parseLong(recordParts[FIRST_ARG_INDEX]);
                    lastTime = startTime;
                    gcEpoch = new GCEpoch(0);
                    gcEpochs.add(gcEpoch);
                    break;

                case FINALIZE_LOG:
                    lastTime = Long.parseLong(recordParts[FIRST_ARG_INDEX]) - startTime; // relative
                    gcEpoch.endTime = lastTime;
                    break;

                case RESET_TIME:
                    lastTime = Long.parseLong(recordParts[FIRST_ARG_INDEX]) - startTime; // relative
                    // find the right gc epoch
                    GCEpoch newGCEpoch = null;
                    for (GCEpoch gce : gcEpochs) {
                        if (lastTime >= gce.startTime && (gce.endTime == 0 || lastTime < gce.endTime)) {
                            newGCEpoch = gce;
                            break;
                        }
                    }
                    assert newGCEpoch != null;
                    gcEpoch = newGCEpoch;
                    break;

                case ADVISE_AFTER_NEW:
                case ADVISE_AFTER_NEW_ARRAY: {
                    getClassRecord(recordParts[ID_CLASSNAME_INDEX]);
                    final long beginCreationTime = lastTime;
                    objectRecord = new ObjectRecord(id, gcEpoch.epoch, classRecord, threadRecord, beginCreationTime);
                    classRecord.addObject(objectRecord);
                    objectsPut(id, objectRecord);
                    if (traceCommand == Key.ADVISE_AFTER_NEW_ARRAY) {
                        objectRecord.setLength((int) expectNumber(recordParts[ID_CLASSNAME_INDEX + 1]));
                        objectRecord.setEndCreationTime(beginCreationTime);
                        arrayCount++;
                    } else {
                        objectCount++;
                    }
                    break;
                }

                case ADVISE_AFTER_INVOKE_SPECIAL:
                    objectRecord = getTraceRecord(id);
                    getMethodName(recordParts[ID_CLASSNAME_INDEX], recordParts[ID_CLASSNAME_INDEX + 1]);
                    if (methodRecord.name.equals("<init>")) {
                        long endCreationTime = lastTime;
                        objectRecord.setEndCreationTime(endCreationTime);
                    }
                    break;

                case REMOVAL: {
                    id = recordParts[1];
                    // This object may have been created in some earlier epoch, so can't use current.
                    // It must be the death of id recorded by maxEpoch
                    objectRecord = objects.get(ObjectRecord.getMapId(id, maxEpoch.get(id)));
                    objectRecord.setDeletionTime(lastTime);
                    break;
                }

                case ADVISE_AFTER_GC: {
                    getTime();
                    gcEpoch.setEndTime(lastTime);
                    gcEpoch = new GCEpoch(lastTime);
                    gcEpochs.add(gcEpoch);
                    break;
                }

                case ADVISE_BEFORE_PUT_FIELD: {
                    objectRecord = getTraceRecord(id);
                    getFieldRecord(recordParts[ID_CLASSNAME_INDEX], recordParts[ID_CLASSNAME_INDEX + 1]);
                    objectRecord.addTraceElement(expectTypeAndValue(ID_CLASSNAME_INDEX + 2));
                    break;
                }

                case ADVISE_BEFORE_PUT_STATIC: {
                    getFieldRecord(recordParts[STATIC_CLASSNAME_INDEX], recordParts[STATIC_CLASSNAME_INDEX + 1]);
                    objectRecord = getStaticTraceRecord(classRecord);
                    objectRecord.addTraceElement(expectTypeAndValue(STATIC_CLASSNAME_INDEX + 2));
                    break;
                }

                case ADVISE_BEFORE_ARRAY_LOAD: {
                    objectRecord = getTraceRecord(id);
                    int arrayIndex = (int) expectNumber(recordParts[ARRAY_INDEX_INDEX]);
                    objectRecord.addTraceElement(new ObjectRecord.ReadTraceElement(null, ArrayIndexRecord.create(arrayIndex), threadRecord, lastTime));
                    break;
                }

                case ADVISE_BEFORE_ARRAY_STORE: {
                    objectRecord = getTraceRecord(id);
                    fieldRecord = ArrayIndexRecord.create((int) expectNumber(recordParts[ARRAY_INDEX_INDEX]));
                    objectRecord.addTraceElement(expectTypeAndValue(ARRAY_INDEX_INDEX + 1));
                    break;
                }
/*
 * case ARRAY_COPY_ID: { td = getTraceRecord(id); st.nextToken(); expectNumber(); int srcPos =
 * Integer.parseInt(st.sval); st.nextToken(); expectWord(); ObjectRecord destTd = getTraceRecord(st.sval);
 * st.nextToken(); expectNumber(); int destPos = Integer.parseInt(st.sval); st.nextToken(); expectNumber(); int length =
 * Integer.parseInt(st.sval); td.addTraceElement(new ObjectRecord.ArrayCopyTraceElement(threadName, lastTime, destPos,
 * destTd, srcPos, length)); break; }
 */

                case UNSEEN: {
                    // This warns of an access to an object that we have not seen the constructor for.
                    // We don't know how or when this was constructed, but give it a creation time of now.
                    getClassRecord(recordParts[ID_CLASSNAME_INDEX]);
                    objectRecord = new ObjectRecord(id, gcEpoch.epoch, classRecord, threadRecord, lastTime);
                    classRecord.addObject(objectRecord);
                    missingConstructors.put(objectRecord.getId(), objectRecord);
                    missingConstructorCount++;
                    objectRecord.setEndCreationTime(lastTime);
                    if (objectRecord.isArray()) {
                        arrayCount++;
                    } else {
                        objectCount++;
                    }
                    objectsPut(id, objectRecord);
                    break;
                }

                case ADVISE_BEFORE_GET_FIELD: {
                    objectRecord = getTraceRecord(id);
                    getFieldRecord(recordParts[ID_CLASSNAME_INDEX], recordParts[ID_CLASSNAME_INDEX + 1]);
                    objectRecord.addTraceElement(new ObjectRecord.ReadTraceElement(classRecord, fieldRecord, threadRecord, lastTime));
                    break;
                }

                case ADVISE_BEFORE_GET_STATIC: {
                    getFieldRecord(recordParts[STATIC_CLASSNAME_INDEX], recordParts[STATIC_CLASSNAME_INDEX + 1]);
                    // class loader object id
                    objectRecord = getStaticTraceRecord(classRecord);
                    objectRecord.addTraceElement(new ObjectRecord.ReadTraceElement(classRecord, fieldRecord, threadRecord, lastTime));
                    break;
                }

                case CLASS_DEFINITION: {
                    defineClass(ClassRecord.getCanonicalName(recordParts[FIRST_ARG_INDEX]), expectNumber(recordParts[FIRST_ARG_INDEX + 1]), recordParts[FIRST_ARG_INDEX + 2]);
                    break;
                }

                case FIELD_DEFINITION: {
                    defineField();
                    break;
                }

                case METHOD_DEFINITION: {
                    defineMethod();
                    break;
                }

                case THREAD_DEFINITION: {
                    ThreadRecord tr = new ThreadRecord(recordParts[FIRST_ARG_INDEX]);
                    threadMap.put(tr.name, tr);
                    threadShortForms.put(recordParts[FIRST_ARG_INDEX + 1], tr.name);
                    break;
                }

                default:
            }
            if (prettyTrace) {
                prettyTrace(traceCommand);
            }
        } catch (TraceException e) {
            System.err.println("line " + lineNumber + ": " + e);
        }
    }

    private void objectsPut(String id, ObjectRecord td) {
        final ObjectRecord old = objects.put(td.getId(), td);
        assert old == null;
        // remember max epoch for resolving unqualified ids
        maxEpoch.put(id, gcEpoch.epoch);
    }

    /**
     * Gets the {@link ObjectRecord} associated with an unqualified id. The qualified id is found using the
     * {@link #maxEpochMap}.
     *
     * @param id
     * @return
     * @throws TraceException
     */
    private ObjectRecord getTraceRecord(String id) throws TraceException {
        if (id.equals("0")) {
            throw new TraceException("trace record with id of zero");
        }
        final String uid = ObjectRecord.getMapId(id, maxEpoch.get(id));
        ObjectRecord td = objects.get(uid);
        if (td == null) {
            throw new TraceException("no creation record for id = " + uid + ", at line " + lineNumber);
        }
        td.traceOccurrences++;
        return td;
    }

    private ObjectRecord getStaticTraceRecord(ClassRecord cr) throws TraceException {
        return cr.getObjects().get(0);
    }

    /**
     * Sets (and returns) {@link #classNameRecord}, handling forward references.
     *
     * @param shortClassName in the trace
     * @throws TraceException
     */
    private ClassRecord getClassRecord(String shortClassName) {
        ClassNameId classNameId = classShortForms.get(shortClassName);
        if (classNameId == null) {
            // forward reference
            classNameId = classForwardsMap.get(shortClassName);
            if (classNameId == null) {
                String forwardName = CLASS_FORWARD_PREFIX + shortClassName;
                classNameId = new ClassNameId(forwardName, ObjectRecord.getMapId("0", gcEpoch.epoch));
                classForwardsMap.put(shortClassName, classNameId);
            }
        }
        classRecord = classMap.get(classNameId);
        if (classRecord == null) {
            classRecord = new ClassRecord(classNameId.className, classNameId.clId);
            classMap.put(classNameId, classRecord);
        }
        return classRecord;
    }

    /**
     * A field name is denoted by a class and field (short forms).
     *
     * @throws IOException
     * @throws TraceException
     */
    private FieldRecord getFieldRecord(String shortClassName, String shortFieldName) {
        ClassRecord cr = getClassRecord(shortClassName);
        String qualName = cr.name + "." + shortFieldName;
        String fieldName = fieldShortForms.get(qualName);
        if (fieldName == null) {
            // forward reference
            fieldName = fieldForwardsMap.get(qualName);
            if (fieldName == null) {
                fieldName = FIELD_FORWARD_PREFIX + shortFieldName;
                fieldForwardsMap.put(qualName, fieldName);
            }
        }
        fieldRecord = fieldMap.get(qualName);
        if (fieldRecord == null) {
            fieldRecord = new FieldRecord(cr, fieldName);
            fieldMap.put(qualName, fieldRecord);
        }
        return fieldRecord;
    }

    /**
     * A method name is denoted by a class and method (short forms).
     *
     * @throws IOException
     * @throws TraceException
     */
    private MethodRecord getMethodName(String shortClassName, String shortMethodName) {
        ClassRecord cr = getClassRecord(shortClassName);
        String qualName = cr.name + "." + shortMethodName;
        String methodName = methodShortForms.get(qualName);
        if (methodName == null) {
            // forward reference
            methodName = methodForwardsMap.get(qualName);
            if (methodName == null) {
                methodName = METHOD_FORWARD_PREFIX + shortMethodName;
                methodForwardsMap.put(qualName, methodName);
            }
        }
        methodRecord = methodMap.get(qualName);
        if (methodRecord == null) {
            methodRecord = new MethodRecord(cr, methodName);
            methodMap.put(qualName, methodRecord);
        }
        return methodRecord;
    }

    /**
     * Class definition, may resolve a previous forward reference.
     */
    private void defineClass(String name, long classLoaderId, String shortForm) {
        // class definition
        ClassNameId className = new ClassNameId(name, getClassLoaderIdAsString(classLoaderId));
        classShortForms.put(shortForm, className);
        // fix up forward reference
        ClassNameId forwardName = classForwardsMap.get(shortForm);
        if (forwardName != null) {
            // find class record in the classMap under the forward name, remove it,
            // patch name/id and add back under new name.
            ClassRecord cr = classMap.remove(forwardName);
            assert cr != null;
            cr.setName(name, getClassLoaderIdAsString(classLoaderId));
            classMap.put(className, cr);
        }
    }

    private String getClassLoaderIdAsString(long clId) {
        return ObjectRecord.getMapId(Long.toString(clId), gcEpoch.epoch);
    }

    private void defineField() {
        String classShortForm = recordParts[FIRST_ARG_INDEX];
        ClassRecord cr = getClassRecord(classShortForm);
        String name = recordParts[FIRST_ARG_INDEX + 1];
        String shortForm = recordParts[FIRST_ARG_INDEX + 2];
        fieldShortForms.put(cr.name + "." + shortForm, name);
        String forwardName = fieldForwardsMap.get(shortForm);
        FieldRecord fr;
        if (forwardName != null) {
            fr = fieldMap.remove(forwardName);
            assert fr != null;
            fr.setName(name);
        } else {
            fr = new FieldRecord(getClassRecord(classShortForm), name);
        }
        fieldMap.put(fr.getQualName(), fr);
    }

    private void defineMethod() {
        String classShortForm = recordParts[FIRST_ARG_INDEX];
        ClassRecord cr = getClassRecord(classShortForm);
        String name = recordParts[FIRST_ARG_INDEX + 1];
        String shortForm = recordParts[FIRST_ARG_INDEX + 2];
        methodShortForms.put(cr.name + "." +  shortForm, name);
        String forwardName = methodForwardsMap.get(shortForm);
        MethodRecord mr;
        if (forwardName != null) {
            mr = methodMap.remove(forwardName);
            assert mr != null;
            mr.setName(name);
            methodMap.put(mr.getQualName(), mr);
        } else {
            mr = new MethodRecord(getClassRecord(classShortForm), name);
        }
        methodMap.put(mr.getQualName(), mr);
    }

    private ObjectRecord.WriteTraceElement expectTypeAndValue(int recordIndex) throws IOException, TraceException {
        char type = recordParts[recordIndex].charAt(0);
        String value = recordParts[recordIndex + 1];
        ObjectRecord.WriteTraceElement wte = null;
        switch (type) {
            case OBJ_VALUE:
                if (value.equals("0")) {
                    wte = new ObjectRecord.NullWriteTraceElement(classRecord, fieldRecord, threadRecord, lastTime);
                } else {
                    final ObjectRecord target = objects.get(value);
                    assert target != null;
                    wte = new ObjectRecord.ObjectWriteTraceElement(classRecord, fieldRecord, threadRecord, lastTime, target);
                }
                break;
            case LONG_VALUE:
                wte = new ObjectRecord.LongWriteTraceElement(classRecord, fieldRecord, threadRecord, lastTime, Long.parseLong(value));
                break;
            case FLOAT_VALUE:
                wte = new ObjectRecord.FloatWriteTraceElement(classRecord, fieldRecord, threadRecord, lastTime, Float.parseFloat(value));
                break;
            case DOUBLE_VALUE:
                wte = new ObjectRecord.DoubleWriteTraceElement(classRecord, fieldRecord, threadRecord, lastTime, Float.parseFloat(value));
                break;
            default:
                throw new IllegalArgumentException("bad type in write value");

        }
        return wte;
    }

    private long getTime() throws IOException, TraceException {
        long timeIncrement = Long.parseLong(recordParts[TIME_INDEX]);
        lastTime += timeIncrement;
        return lastTime;
    }

    private long expectNumber(String arg) throws TraceException {
        if (!(arg.charAt(0) >= '0' || arg.charAt(0) <= '9')) {
            throw new TraceException("number expected at line " + lineNumber);
        } else {
            return Long.parseLong(arg);
        }
    }

    private Key expectValidTraceStart() throws TraceException {
        Key result = commandMap.get(recordParts[KEY_INDEX]);
        if (result == null) {
            throw new TraceException("unknown trace command at line " + lineNumber);
        } else {
            return result;
        }
    }

    private void getTimeAndThread() throws TraceException, IOException {
        getTime();
        // N.B. there can be no forward references to threads
        String threadName = threadShortForms.get(recordParts[THREAD_INDEX]);
        threadRecord = threadMap.get(threadName);

    }

    private void prettyTrace(Key traceCommand) {
        String arg1 = recordParts[1];
        String arg2 = recordParts.length > 2 ? recordParts[2] : null;
        String arg3 = recordParts.length > 3 ? recordParts[3] : null;
        String arg4 = recordParts.length > 4 ? recordParts[4] : null;
        String logTime = arg1;
        String objId = arg2;
        String threadId = TextVMAdviceHandlerLog.hasTimeAndThread(traceCommand) ? threadRecord.name : "N/A";

        System.out.printf("@%d in %s %s", lastTime, threadId, traceCommand);

        switch (traceCommand) {
            case INITIALIZE_LOG:
                System.out.printf(" %s", arg2);
                break;
            case FINALIZE_LOG:
                break;

            case CLASS_DEFINITION:
                System.out.printf(" %s %s %s", arg1, arg2, arg3);
                break;
            case FIELD_DEFINITION:
            case THREAD_DEFINITION:
            case METHOD_DEFINITION:
                System.out.printf(" %s %s", arg1, arg2);
                break;

            case ADVISE_AFTER_NEW:
            case ADVISE_AFTER_NEW_ARRAY:
                System.out.printf(" %s %s", objectRecord, classRecord);
                if (traceCommand == Key.ADVISE_AFTER_NEW_ARRAY) {
                    System.out.printf(" %s", objectRecord.getLength());
                }
                break;

            case UNSEEN:
                System.out.printf(" %s %s", objectRecord, classRecord);
                break;

            case ADVISE_BEFORE_THROW:
            case ADVISE_BEFORE_IF:
            case ADVISE_BEFORE_LOAD:
            case ADVISE_BEFORE_BYTECODE:
            case ADVISE_AFTER_MULTI_NEW_ARRAY:
            case ADVISE_BEFORE_STORE:
            case ADVISE_BEFORE_INSTANCE_OF:
                break;

            case ADVISE_BEFORE_ARRAY_LOAD:
            case ADVISE_BEFORE_ARRAY_STORE:
                System.out.printf(" %s %s", objectRecord, fieldRecord);
                if (traceCommand == Key.ADVISE_BEFORE_ARRAY_STORE) {
                    System.out.printf(" %s", recordParts[ARRAY_INDEX_INDEX]);
                }
                break;

            case ADVISE_BEFORE_GET_STATIC:
            case ADVISE_BEFORE_PUT_STATIC:
                System.out.printf(" %s", fieldRecord);
                if (traceCommand == Key.ADVISE_BEFORE_PUT_STATIC) {
                    System.out.printf(" %s %s", recordParts[STATIC_CLASSNAME_INDEX + 2], recordParts[STATIC_CLASSNAME_INDEX + 3]);
                }
                break;

            case ADVISE_BEFORE_GET_FIELD:
            case ADVISE_BEFORE_PUT_FIELD:
                System.out.printf(" %s %s", objectRecord, fieldRecord);
                if (traceCommand == Key.ADVISE_BEFORE_PUT_FIELD) {
                    System.out.printf(" %s %s", recordParts[ID_CLASSNAME_INDEX + 2], recordParts[ID_CLASSNAME_INDEX + 3]);
                }
                break;

            case ADVISE_BEFORE_MONITOR_ENTER:
            case ADVISE_BEFORE_MONITOR_EXIT:
                System.out.printf(" %s", objectRecord);
                break;

            case ADVISE_BEFORE_ARRAY_LENGTH:
            case REMOVAL:
            case ADVISE_BEFORE_CHECK_CAST:
            case ADVISE_BEFORE_IPUSH:
            case ADVISE_AFTER_GC:
            case ADVISE_BEFORE_IINC:
            case ADVISE_BEFORE_OPERATION:

            case ADVISE_BEFORE_INVOKE_INTERFACE:
            case ADVISE_AFTER_INVOKE_INTERFACE:
            case ADVISE_BEFORE_INVOKE_STATIC:
            case ADVISE_AFTER_INVOKE_STATIC:
            case ADVISE_BEFORE_INVOKE_VIRTUAL:
            case ADVISE_AFTER_INVOKE_VIRTUAL:
            case ADVISE_BEFORE_INVOKE_SPECIAL:
            case ADVISE_AFTER_INVOKE_SPECIAL:
                System.out.printf(" %s %s", objectRecord, methodRecord);
                break;

            case ADVISE_BEFORE_STACK_ADJUST:
            case ADVISE_BEFORE_GC:
            case ADVISE_BEFORE_RETURN:
            case ADVISE_BEFORE_CONVERSION:
            case ADVISE_BEFORE_THREAD_TERMINATING:
            case ADVISE_BEFORE_THREAD_STARTING:
            case ADVISE_BEFORE_CONST_LOAD:
            case RESET_TIME:

        }
        System.out.println();
    }

}

