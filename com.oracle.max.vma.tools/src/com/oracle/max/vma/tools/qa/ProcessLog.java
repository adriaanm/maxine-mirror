/*
 * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.oracle.max.vma.tools.qa;

import static com.oracle.max.vm.ext.vma.log.txt.TextVMAdviceHandlerLog.*;

import java.io.*;
import java.util.*;

import com.oracle.max.vm.ext.vma.log.txt.*;

/**
 * Reads a log file in the format generated by {@link CompactTextObjectTrackerLog}.
 *
 * Object identifiers in the log may be reused owing to garbage collection.
 * Object identifiers in the {@link #objects} map are unique and always qualified
 * by the allocation (gc) epoch, {@link #gcEpoch). I.e., an id X in the log
 * is stored as "X:gcEpoch", e.g. "X:0, X:3, ..."
 *
 * The log may not be time ordered in that the events for separate threads
 * may be batched together. However, in this case, each batch starts with
 * a {@link RESET_TIME_ID} event that sets the start time for the batch,
 * allowing proper time management.
 *
 * Note that although the map may contain many instances of X:n, at any point in time
 * there can only be one active instance, which is the value of "n" given by
 * the {@link #maxEpoch} map. Note also, in logs that are
 * not time ordered it is not entirely trivial to map an unqualified id to
 * the correct definition, since a use may precede its definition (construction).
 * This is resolved by correlating the time of the event and the time of the
 * gc epochs.
 *
 * N.B. Currently non-time ordered logs cannot be handled by this code.
 * They must first be processed with {@link ConvertLog}.
 *
 */
public class ProcessLog {

    private boolean verbose = false;
    private boolean prettyTrace;
    private int maxLines;

    String dataFile;

    private Map<String, ObjectRecord> objects = new HashMap<String, ObjectRecord>(1024 * 1024);

    private Map<Long, SortedMap<String, ClassRecord>> classLoaders = new HashMap<Long, SortedMap<String, ClassRecord>>();

    private ArrayList<GCEpoch> gcEpochs = new ArrayList<GCEpoch>();

    private long objectCount = 0;

    private long arrayCount = 0;

    private int missingConstructorCount = 0;

    private long startTime; // absolute value in trace
    private long lastTime;  // relative value starting at zero
    private GCEpoch gcEpoch;
    private Map<String, Integer> maxEpoch = new HashMap<String, Integer>();
    private Map<String, String> lastId = new HashMap<String, String>();
    private String fieldName;
    private String threadName;
    private String className;

    private StreamTokenizer st = null;

    private Map<String, ObjectRecord> missingConstructors = new HashMap<String, ObjectRecord>();

    private Map<String, String> classShortForms = new HashMap<String, String>();
    private Map<String, String> fieldShortForms = new HashMap<String, String>();
    private Map<String, String> threadShortForms = new HashMap<String, String>();
    private Map<String, String> arrayIndices = new HashMap<String, String>(); // intern string table for array indices

    private Map<String, String> classForwardsMap = new HashMap<String, String>();
    private Map<String, String> fieldForwardsMap = new HashMap<String, String>();
    private static final String FIELD_FORWARD_PREFIX = "FieldForward-";
    private static final String CLASS_FORWARD_PREFIX = "ClassForward-";

    private ProcessLog(String dataFile, boolean verbose, boolean prettyTrace, int maxLines) throws IOException {
        this.st = new StreamTokenizer(new BufferedReader(new FileReader(
                dataFile)));
        Util.resetStreamTokenizer(st);
        this.dataFile = dataFile;
        this.verbose = verbose;
        this.prettyTrace = prettyTrace;
        this.maxLines = maxLines;
    }

    public static TraceRun processTrace(String dataFile, boolean verbose, boolean prettyTrace, int maxLines) throws IOException {
        ProcessLog pt = new ProcessLog(dataFile, verbose, prettyTrace, maxLines);
        return pt.doProcessTrace();
    }

    private TraceRun doProcessTrace() throws IOException {
        long linecount = 0;
        long startTime = System.currentTimeMillis();
        long chunkStartTime = startTime;

        if (verbose) {
            System.out.println("processing trace file " + dataFile
                    + " starting");
        }

        st.nextToken();
        while (st.ttype != StreamTokenizer.TT_EOF) {
            processTraceRecord();
            while ((st.ttype != StreamTokenizer.TT_EOL)
                    && (st.ttype != StreamTokenizer.TT_EOF)) {
                st.nextToken();
            }
            linecount++;
            if (linecount >= maxLines) {
                System.out.println("reached max line count - terminating processing");
                break;
            }
            if (verbose && ((linecount % 100000) == 0)) {
                long endTime = System.currentTimeMillis();
                System.out.println("processed " + linecount + " traces in "
                        + (endTime - startTime) + " ms " + "("
                        + (endTime - chunkStartTime) + ")");
                chunkStartTime = endTime;
            }
            do {
                st.nextToken();
            } while (st.ttype == StreamTokenizer.TT_EOL);
        }
        if (verbose) {
            System.out.println("processing trace file " + dataFile
                    + " complete");
        }
        TraceRun result = new TraceRun(dataFile, objects, classLoaders,
                missingConstructors, objectCount, arrayCount,
                missingConstructorCount, gcEpochs, lastTime);

        // fixup forward references to fields
        if (fieldForwardsMap.size() > 0) {
            final Iterator<ClassRecord> classIter = result.getClassesIterator();
            while (classIter.hasNext()) {
                final ClassRecord cr = classIter.next();
                for (ObjectRecord or : cr.getObjects()) {
                    final Iterator<ObjectRecord.TraceElement> trIter = or.getTraceElements().iterator();
                    while (trIter.hasNext()) {
                        final ObjectRecord.TraceElement traceElement = trIter.next();
                        final String fieldName = traceElement.getFieldName();
                        if (fieldName.startsWith(FIELD_FORWARD_PREFIX)) {
                            final String shortForm = fieldName.substring(FIELD_FORWARD_PREFIX.length());
                            traceElement.setFieldName(fieldShortForms.get(shortForm));
                        }
                    }

                }
            }
        }

        return result;
    }

    private void processTraceRecord() throws IOException {
        try {
            String id = null;
            Key traceCommand = expectValidTraceStart();
            if (traceCommand == Key.ADVISE_BEFORE_RETURN) {
                System.console();
            }
            if (TextVMAdviceHandlerLog.hasTimeAndThread(traceCommand)) {
                st.nextToken();
                expectTimeAndThread();
            }
            if (TextVMAdviceHandlerLog.hasId(traceCommand)) {
                st.nextToken();
                expectWord();
                if (st.sval.charAt(0) == REPEAT_ID) {
                    id = lastId.get(threadName);
                } else {
                    // This gets the gc epoch qualification later
                    id = st.sval;
                    lastId.put(threadName, id);
                }
            }
            ObjectRecord td = null;
            switch (traceCommand) {
                case INITIALIZE_LOG:
                    st.nextToken();
                    startTime = Long.parseLong(st.sval);
                    gcEpoch = new GCEpoch(0);
                    gcEpochs.add(gcEpoch);
                    break;

                case FINALIZE_LOG:
                    st.nextToken();
                    lastTime = Long.parseLong(st.sval) - startTime; // relative
                    gcEpoch.endTime = lastTime;
                    break;

                case RESET_TIME:
                    st.nextToken();
                    lastTime = Long.parseLong(st.sval) - startTime; // relative
                    // find the right gc epoch
                    GCEpoch newGCEpoch = null;
                    for (GCEpoch gce : gcEpochs) {
                        if (lastTime >= gce.startTime && (gce.endTime == 0 || lastTime < gce.endTime)) {
                            newGCEpoch = gce;
                            break;
                        }
                    }
                    assert newGCEpoch != null;
                    gcEpoch = newGCEpoch;
                    if (prettyTrace) {
                        System.out.println("@" + lastTime + " " + traceCommand);
                    }
                    break;

                case ADVISE_AFTER_NEW:
                case ADVISE_AFTER_NEW_ARRAY: {
                    getClassName();
                    // class loader object id
                    long classLoaderId = getClassLoader();
                    final long beginCreationTime = lastTime;
                    ClassRecord cr = addClass(className, classLoaderId);
                    td = new ObjectRecord(id, gcEpoch.epoch, cr, threadName, beginCreationTime);
                    cr.addObject(td);
                    objectsPut(id, td);
                    if (traceCommand == Key.ADVISE_AFTER_NEW_ARRAY) {
                        st.nextToken();
                        expectNumber();
                        td.setLength(Integer.parseInt(st.sval));
                        td.setEndCreationTime(beginCreationTime);
                        arrayCount++;
                        prettyTrace(traceCommand, td, st.sval);
                    } else {
                        objectCount++;
                        prettyTrace(traceCommand, td);
                    }
                    break;
                }

                case ADVISE_AFTER_INVOKE_SPECIAL:
                    td = getTraceRecord(id);
                    long endCreationTime = lastTime;
                    td.setEndCreationTime(endCreationTime);
                    prettyTrace(traceCommand, td);
                    break;

                case REMOVAL: {
                    st.nextToken();
                    expectWord();
                    id = st.sval;
                    // This object may have been created in some earlier epoch, so can't use current.
                    // It must be the death of id recorded by maxEpoch
                    td = objects.get(ObjectRecord.getMapId(id, maxEpoch.get(id)));
                    td.setDeletionTime(lastTime);
                    if (prettyTrace) {
                        System.out.println("@" + lastTime + " " + traceCommand + " " + id);
                    }
                    break;
                }

                case ADVISE_AFTER_GC: {
                    st.nextToken();
                    expectTime();
                    gcEpoch.setEndTime(lastTime);
                    gcEpoch = new GCEpoch(lastTime);
                    gcEpochs.add(gcEpoch);
                    break;
                }

                case ADVISE_BEFORE_PUT_FIELD: {
                    td = getTraceRecord(id);
                    getFieldName();
                    td.addTraceElement(expectTypeAndValue(false));
                    prettyTrace(traceCommand, td, fieldName);
                    break;
                }

                case ADVISE_BEFORE_PUT_STATIC: {
                    getClassName();
                    // class loader object id
                    long classLoaderId = getClassLoader();
                    td = getStaticTraceRecord(className, classLoaderId);
                    getFieldName();
                    td.addTraceElement(expectTypeAndValue(false));
                    prettyTrace(traceCommand, td, fieldName);
                    break;
                }

                case ADVISE_BEFORE_ARRAY_LOAD:
                    td = getTraceRecord(id);
                    st.nextToken();
                    expectNumber();
                    fieldName = st.sval;
                    td.addTraceElement(new ObjectRecord.ReadTraceElement(fieldName, threadName, lastTime));
                    prettyTrace(traceCommand, td, fieldName);
                    break;

                case ADVISE_BEFORE_ARRAY_STORE: {
                    td = getTraceRecord(id);
                    td.addTraceElement(expectTypeAndValue(true));
                    prettyTrace(traceCommand, td, fieldName);
                    break;
                }
/*
                case ARRAY_COPY_ID: {
                    td = getTraceRecord(id);
                    st.nextToken();
                    expectNumber();
                    int srcPos = Integer.parseInt(st.sval);
                    st.nextToken();
                    expectWord();
                    ObjectRecord destTd = getTraceRecord(st.sval);
                    st.nextToken();
                    expectNumber();
                    int destPos = Integer.parseInt(st.sval);
                    st.nextToken();
                    expectNumber();
                    int length = Integer.parseInt(st.sval);
                    td.addTraceElement(new ObjectRecord.ArrayCopyTraceElement(threadName, lastTime, destPos, destTd, srcPos, length));
                    break;
                }
                */

                case UNSEEN: {
                    // This warns of an access to an object that we have not seen
                    // the constructor for.
                    // We don't know how or when this was constructed, but give it a
                    // creation time of now.
                    st.nextToken();
                    expectTime();
                    st.nextToken();
                    expectWord();
                    id = st.sval;
                    getClassName();
                    long classLoaderId = getClassLoader();
                    ClassRecord cr = addClass(className, classLoaderId);
                    threadName = "<unseen>";
                    td = new ObjectRecord(id, gcEpoch.epoch, cr, threadName, lastTime);
                    cr.addObject(td);
                    missingConstructors.put(td.getId(), td);
                    missingConstructorCount++;
                    // This is our best assumption as we will not see an
                    // OBJECT_CREATION_END.
                    // However, if we see a NEW_INSTANCE we will update the
                    // endCreation time then,
                    // which will be accurate.
                    td.setEndCreationTime(lastTime);
                    if (td.isArray()) {
                        arrayCount++;
                    } else {
                        objectCount++;
                    }
                    objectsPut(id, td);
                    prettyTrace(traceCommand, td);
                    break;
                }

                case ADVISE_BEFORE_GET_FIELD: {
                    td = getTraceRecord(id);
                    getFieldName();
                    td.addTraceElement(new ObjectRecord.ReadTraceElement(fieldName, threadName, lastTime));
                    prettyTrace(traceCommand, td, fieldName);
                    break;
                }

                case ADVISE_BEFORE_GET_STATIC: {
                    getClassName();
                    getFieldName();
                    // class loader object id
                    long classLoaderId = getClassLoader();
                    td = getStaticTraceRecord(className, classLoaderId);
                    td.addTraceElement(new ObjectRecord.ReadTraceElement(fieldName, threadName, lastTime));
                    prettyTrace(traceCommand, td, fieldName);
                    break;
                }

                case CLASS_DEFINITION: {
                    st.nextToken();
                    expectWord();
                    className = st.sval;
                    // short name
                    st.nextToken();
                    expectWord();
                    String shortForm = st.sval;
                    // class loader object id
                    long classLoaderId = getClassLoader();
                    addClass(ClassRecord.getCanonicalName(className), classLoaderId, shortForm);
                    break;
                }

                case FIELD_DEFINITION: {
                    st.nextToken();
                    expectWord();
                    final String fullFieldName = st.sval;
                    st.nextToken();
                    expectWord();
                    fieldShortForms.put(st.sval, fullFieldName);
                    break;
                }

                case THREAD_DEFINITION: {
                    st.nextToken();
                    String fullThreadName;
                    // thread names may be quoted
                    if (st.ttype == '"') {
                        fullThreadName = st.sval;
                    } else {
                        expectWord();
                        fullThreadName = st.sval;
                    }
                    st.nextToken();
                    expectWord();
                    threadShortForms.put(st.sval, fullThreadName);
                    break;
                }

                default:
                    prettyTrace(traceCommand, null, "unimplemented ");
            }

        } catch (TraceException e) {
            System.err.println("line " + st.lineno() + ": " + e);
        }
    }

    private void objectsPut(String id, ObjectRecord td) {
        final ObjectRecord old = objects.put(td.getId(), td);
        assert old == null;
        // remember max epoch for resolving unqualified ids
        maxEpoch.put(id, gcEpoch.epoch);
    }

    private void prettyTrace(Key traceCommand, ObjectRecord td) {
        prettyTrace(traceCommand, td, null);
    }

    private void prettyTrace(Key traceCommand, ObjectRecord td, String xtra) {
        if (prettyTrace) {
            System.out.println("@" + lastTime + " " + traceCommand + " " + (td == null ? "" : (td.getId())) + " " +
                    (td == null ? "" : td.getClassName()) +
                    (xtra == null ? "" : " " + xtra) + " in " + threadName);
        }
    }

    /**
     * Gets the {@link ObjectRecord} associated with an unqualified id.
     * The qualified id is found using the {@link #maxEpochMap}.
     * @param id
     * @return
     * @throws TraceException
     */
    private ObjectRecord getTraceRecord(String id) throws TraceException {
        if (id.equals("0")) {
            throw new TraceException("trace record with id of zero");
        }
        final String uid = ObjectRecord.getMapId(id, maxEpoch.get(id));
        ObjectRecord td = objects.get(uid);
        if (td == null) {
            throw new TraceException("no creation record for id = " + uid + ", at line " + st.lineno());
        }
        td.traceOccurrences++;
        return td;
    }

    private ObjectRecord getStaticTraceRecord(String className,
            long classLoaderId) throws TraceException {
        ClassRecord cr = addClass(className, classLoaderId);
        return cr.getObjects().get(0);
    }

    private void getClassName() throws IOException, TraceException {
        st.nextToken();
        expectWord();
        className = classShortForms.get(st.sval);
        if (className == null) {
            // forward reference
            className = classForwardsMap.get(st.sval);
            if (className == null) {
                className = CLASS_FORWARD_PREFIX + st.sval;
                classForwardsMap.put(st.sval, className);
            }

        }
    }

    private void getFieldName() throws IOException, TraceException {
        st.nextToken();
        expectWord();
        fieldName = fieldShortForms.get(st.sval);
        if (fieldName == null) {
            // forward reference
            fieldName = fieldForwardsMap.get(st.sval);
            if (fieldName == null) {
                fieldName = "FieldForward-" + st.sval;
                fieldForwardsMap.put(st.sval, fieldName);
            }
        }
    }

    private long getClassLoader() throws IOException, TraceException {
        st.nextToken();
        expectNumber();
        return  Long.parseLong(st.sval);
    }

    private ClassRecord addClass(String className, long classLoaderId) throws TraceException {
        return addClass(className, classLoaderId, null);
    }

    private ClassRecord addClass(String className, long classLoaderId,
            String shortForm) throws TraceException {
        SortedMap<String, ClassRecord> clmap = classLoaders.get(classLoaderId);
        if (clmap == null) {
            // object allocated by a classloader we haven't seen before
            clmap = new TreeMap<String, ClassRecord>();
            classLoaders.put(classLoaderId, clmap);
        }
        if (shortForm != null) {
            // class definition
            classShortForms.put(shortForm, className);
            // fix up forward reference
            String forwardName = classForwardsMap.get(shortForm);
            if (forwardName != null) {
                // find class record in the clmap under the forward name, remove it,
                // patch name and add back under new name.
                ClassRecord fcr = clmap.remove(forwardName);
                assert fcr != null;
                fcr.setName(className);
                clmap.put(className, fcr);
            }
        }
        ClassRecord cr = clmap.get(className);
        if (cr == null) {
            ArrayList<ObjectRecord> traces = new ArrayList<ObjectRecord>();
            cr = new ClassRecord(className, classLoaderId, traces);
            clmap.put(className, cr);
            // add entry for tracing static fields
            ObjectRecord std = new ObjectRecord(null, gcEpoch.epoch, cr, null, -1);
            traces.add(std);
        }
        return cr;
    }

    private ObjectRecord.WriteTraceElement expectTypeAndValue(boolean expectIndex) throws IOException, TraceException {
        st.nextToken();
        expectWord();
        char type = st.sval.charAt(0);
        st.nextToken();
        expectWord();
        String value = st.sval;
        if (expectIndex) {
            st.nextToken();
            expectNumber();
            fieldName = arrayIndices.get(st.sval);
            if (fieldName == null) {
                arrayIndices.put(st.sval, st.sval);
                fieldName = st.sval;
            }
        }
        st.nextToken();
        ObjectRecord.WriteTraceElement wte = null;
        switch (type) {
            case OBJ_VALUE:
                if (value.equals("0")) {
                    wte = new ObjectRecord.NullWriteTraceElement(fieldName, threadName, lastTime);
                } else {
                    final ObjectRecord target = objects.get(value);
                    if (target == null) {
                        wte = new ObjectRecord.UnseenWriteTraceElement(fieldName, threadName, lastTime, value);
                    } else {
                        wte = new ObjectRecord.ObjectWriteTraceElement(fieldName, threadName, lastTime, target);
                    }
                }
                break;
            case LONG_VALUE:
                wte = new ObjectRecord.LongWriteTraceElement(fieldName, threadName, lastTime, Long.parseLong(value));
                break;
            case FLOAT_VALUE:
                wte = new ObjectRecord.FloatWriteTraceElement(fieldName, threadName, lastTime, Float.parseFloat(value));
                break;
            case DOUBLE_VALUE:
                wte = new ObjectRecord.DoubleWriteTraceElement(fieldName, threadName, lastTime, Float.parseFloat(value));
                break;
            default:
                throw new IllegalArgumentException("bad type in write value");

        }
        return wte;
    }

    private long expectTime() throws IOException, TraceException {
        expectNumber();
        long timeIncrement = Long.parseLong(st.sval);
        lastTime += timeIncrement;
        return lastTime;
    }

    private void expectWord() throws TraceException {
        if (st.ttype != StreamTokenizer.TT_WORD) {
            throw new TraceException("word expected at line " + st.lineno());
        }
    }

    private void expectNumber() throws TraceException {
        if (!((st.ttype == StreamTokenizer.TT_WORD)
                && ((st.sval.charAt(0) >= '0') || (st.sval.charAt(0) <= '9')))) {
            throw new TraceException("number expected at line " + st.lineno());
        }

    }

    private boolean isCommand(String c) {
        return commandMap.get(c) != null;
    }

    private Key expectValidTraceStart() throws TraceException {
        if (!((st.ttype == StreamTokenizer.TT_WORD)
                && isCommand(st.sval))) {
            throw new TraceException("unknown trace command at line "
                            + st.lineno());
        } else {
            return commandMap.get(st.sval);
        }
    }

    private void expectTimeAndThread() throws TraceException, IOException {
        expectTime();
        st.nextToken();
        expectWord();
        threadName = threadShortForms.get(st.sval);
    }

    class TraceException extends Exception {
        static final long serialVersionUID = 0;
        TraceException(String s) {
            super(s);
        }
    }

}

